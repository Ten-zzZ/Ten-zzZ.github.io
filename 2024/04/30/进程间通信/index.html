<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>进程间通信 | Ten-zzZ</title><meta name="keywords" content="linux,通信"><meta name="author" content="Ten"><meta name="copyright" content="Ten"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="进程间通信"><meta name="application-name" content="进程间通信"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="进程间通信"><meta property="og:url" content="http://example.com/2024/04/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/index.html"><meta property="og:site_name" content="Ten-zzZ"><meta property="og:description" content="引言进程间通信（interprocess communication，简称 IPC） 指两个进程之间的通信。 系统中的每一个进程都有各自的地址空间，并且相互独立、隔离， 每个进程都处于自己的地址空间中。 所以同一个进程的不同模块（譬如不同的函数）之间进行通信都是很简单的，譬如使用全局变量等。但是，两"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://img2.imgtp.com/2024/04/30/9GnvXoDg.png"><meta property="article:author" content="Ten"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img2.imgtp.com/2024/04/30/9GnvXoDg.png"><meta name="description" content="引言进程间通信（interprocess communication，简称 IPC） 指两个进程之间的通信。 系统中的每一个进程都有各自的地址空间，并且相互独立、隔离， 每个进程都处于自己的地址空间中。 所以同一个进程的不同模块（譬如不同的函数）之间进行通信都是很简单的，譬如使用全局变量等。但是，两"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2024/04/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: {"mode":"api","api":"https://github.com/anzhiyu-c/img2color-go","cover_change":true},
  authorStatus: {"skills":["🌐 浏览器里的探险家"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Ten","link":"链接: ","source":"来源: Ten-zzZ","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Ten-zzZ',
  title: '进程间通信',
  postAI: '',
  pageFillDescription: '引言, 管道, 匿名管道, 命名管道, 消息队列, 创建或打开消息队列：, 添加消息, 读取消息, 消息队列的控制, 共享内存, 创建或获取——shmget(), 连接——shmat(), 分离——shmdt(), 控制——shmctl(), 信号, 信号的分类, 进程对信号的处理, signal()函数, sigaction()函数, 向进程发送信号, kill()函数, raise()函数, alarm()和 pause()函数, alarm()函数, pause()函数, 信号集, 初始化信号集, 向信号集中添加x2F删除信号, 测试信号是否在信号集中, 获取信号描述信息, strsignal()函数 ：, psignal()函数, 信号掩码, 阻塞等待信号sigsuspend(), 实时性信号, sigpending()函数, 发送实时信号, 异常退出 abort()函数引言进程间通信简称指两个进程之间的通信系统中的每一个进程都有各自的地址空间并且相互独立隔离每个进程都处于自己的地址空间中所以同一个进程的不同模块譬如不同的函数之间进行通信都是很简单的譬如使用全局变量等但是两个不同的进程之间要进行通信通常是比较难的因为这两个进程处于不同的地址空间中通常情况下大部分的程序是不要考虑进程间通信的因为大家所接触绝大部分程序都是单进程程序可以有多个线程对于一些复杂大型的应用程序则会根据实际需要将其设计成多进程程序譬如服务区应用程序等进程间通信通常有管道消息队列信号量共享内存其中和支持两个不同主机间的进程通信管道把一个进程连接到另一个进程的数据流称为管道管道被抽象成一个文件这种文件叫管道文件都是该文件不属于如何文件系统管道分为匿名管道和命名管道匿名管道匿名管道的特点也称为无名管道是最常用的管道半双工同一时间只能由一端传送给另一端只能在父子或者兄弟进程间使用管道的本质是文件管道文件不属于任何文件系统用于创建一个匿名管道返回值成功返回失败返回并且设置参数介绍为文件描述符数组其中表示读端表示写端父子进程通信过程解析父进程创建管道得到两个文件描述符指向管道的两端父进程出子进程子进程也有两个文件描述符指向同一个管道父进程关闭读端子进程关闭写端因为管道只支持单向通信也可父写子读示例子进程写数据父进程读数据创建管道创建子进程子进程写数据父进程读数据我是子进程关闭读功能以下是父进程执行的内容我是父进程关闭写功能我是子进程我是父进程命名管道不同于匿名管道之处在于它提供一个路径名与之关联以的文件形式存储于文件系统中说白了就是命名管道会以文件存储在系统中命名管道特征可以进行不相干进程间的通信命名管道是一个文件对于文件的相关操作对其同样适用对于管道文件当前进程操作为只读时则进行阻塞直至有进程对其写入数据对于管道文件当前进程操作为只写时则进行阻塞直至有进程从管道中读取数据用于创建一个命名管道返回值成功都返回失败都返回并会设置参数介绍创建的命名管道的全路径名指定了文件的读写权限注意命名管道和匿名管道的使用方法法基本是相同的只是使用命名管道时必须先调用将其打开因为命名管道是一个存在于硬盘上的文件而匿名管道是存在于内存中的特殊文件调用打开命名管道的进程可能会被阻塞但如果同时用读写方式打开则一定不会导致阻塞如果以只读方式打开则调用函数的进程将会被阻塞直到有写方打开管道同样以只写方式打开也会阻塞直到有读方式打开管道示例服务端读数据的进程将权限清创建管道打开管道请等待过滤服务器当客户端退出时返回客户端退出自己退出客户端写数据的进程打开管道客户端向管道文件中写数据以字符串的形式写消息队列是消息的链接表存放在内核中一个消息队列由一个标识符即队列来标识消息队列特点消息队列是面向记录的其中的消息具有特定的格式以及特定的优先级消息队列独立于发送与接收进程进程终止时消息队列及其内容并不会被删除消息队列可以实现消息的随机查询消息不一定要以先进先出的次序读取也可以按消息的类型读取头文件系统建立通讯如消息队列共享内存时必须指定一个值通常情况下该值通过函数得到返回值当成功执行的时候一个值将会被返回否则被返回参数介绍传入一个路径一般是当前路径随便填写一个数要做通信的话通信的另外一端要与这个数保持一致才能找到对应的创建或打开消息队列返回值成功返回队列失败返回参数介绍是一个键值由获得通信双方要想通信值要一样标识函数的行为以及消息队列的权限创建消息队列检测消息队列是否存在位或权限位消息队列位或权限位后可以设置消息队列的访问权限格式和函数的一样但可执行权限未使用添加消息返回值成功返回失败返回参数介绍消息对象要是的消息的结构体变量的地址消息结构消息的类型消息的内容消息正文的字节数等于消息结构体的大小减去类型的大小调用阻塞直到条件满足为止若消息没有立刻发送则调用该函数的进程会立刻返回读取消息返回值成功返回消息数据的长度失败返回参数介绍消息队列的标识符代表要从哪个消息队列中获取消息存放消息的结构体地址消息正文的字节数感兴趣的消息类型可以有以下几种类型返回队列中第一个消息返回队列中消息类型为的消息返回队列中消息类型小于等于的绝对值的消息如果这种消息有若干个则取类型值最小的消息函数的控制属性调用阻塞直到接收消息成功为止若返回的消息字节数比字节数多则消息就会截断到字节且不通知消息发送进程调用进程会立即返回若没有收到消息则立即返回消息队列的控制对消息队列进行各种控制如删除消息队列修改消息队列的属性返回值成功返回失败返回参数介绍消息队列的标识符函数功能的控制删除由标识的消息队列将他从系统中删除并破坏相关的数据结将相关的数据结构中各个元素的当前值存入到由指向的结构中将相关的数据结构中的元素设置为由指向的结构中的对应值数据类型的地址用来存放或更改消息队列的属性示例进程消息结构消息的类型消息的内容从队列中读取消息读取类型为的数据发送消息道队列我是进程发送类型为的数据删除消息队列进程消息的类型消息的内容发送消息道队列我是进程发送类型为的数据从队列中读取消息读取类型为的数据删除消息队列共享内存共享内存就是映射一段能被其它进程所访问的内存这段共享内存由一个进程创建但其它的多个进程都可以访问使得多个进程可以访问同一块内存空间共享内存是最快的方式它是针对其它进程间通信方式运行效率低而专门设计的它往往与其它通信机制譬如结合信号量来使用以实现进程间的同步和通信共享内存指两个或多个进程共享一个给定的存储区共享内存特点共享内存是最快的一种因为进程是直接对内存进行存取因为多个进程可以同时操作所以需要进行同步信号量共享内存通常结合在一起使用信号量用来同步对共享内存的访问共享内存操作步骤创建共享内存打开共享内存连接连接该共享内存到当前进程的地址空间连接成功后把共享内存区对象映射到调用进程的地址空间随后可像本地空间一样访问读写数据分离并不是从系统中删除该共享内存只是当前进程不能再访问该共享内存而已销毁从系统中删除该共享内存头文件创建或获取创建或获取一个共享内存返回值成功返回共享内存失败返回参数介绍是一个键值由获得用于唯一标识一块共享内存共享内存大小而如果引用一个已存在的共享内存则将指定为该参数用于确定共享内存属性标志位内存权限值得注意无法单独使用连接创建共享内存后还不能直接使用需要找到内存地址后才能使用即连接返回值连接成功返回共享内存在进程中的起始地址失败返回参数介绍共享内存即的创建成功的返回值用于确定将共享内存挂在进程虚拟地址哪个位置一般填即可代表让内核自己确定位置用于确定挂接方式一般填分离当使用共享内存完毕后需要分离挂接的共享内存注意这并不是从系统中删除该共享内存只是当前进程不能再访问该共享内存而已返回值分离成功返回失败返回参数介绍为共享内存在进程中地址位置一般填控制该接口本身用于控制共享内存可用于销毁返回值成功返回失败返回参数介绍共享内存即的创建成功的返回值函数功能的控制销毁由标识的共享内存传该指令为系统指令使用时可以查看当前全部共享内存通过指定共享内存进行删除示例进程创建共享内存连接映射往共享内存映射在进程空间中的内存中写数据等待进程读取完分离销毁共享内存已销毁进程打开共享内存连接映射从共享内存映射在进程空间中的内存中读数据并打印分离销毁另一个进程已经销毁共享内存已销毁信号信号是事件发生时对进程的通知机制也可以把它称为软件中断信号与硬件中断的相似之处在于能够打断程序当前执行的正常流程其实是在软件层次上对中断机制的一种模拟大多数情况下是无法预测信号达到的准确时间所以信号提供了一种处理异步事件的方法信号的目的是用来通信的用于通知接收信号的进程有某种事件发生所以可用于进程间通信除了用于进程间通信之外进程还可以发送信号给进程本身信号的分类系统下可以从两个角度对信号进行分类从可靠性方面将信号分为可靠信号与不可靠信号从实时性方面将信号分为实时信号与非实时信号可靠信号可靠信号支持排队不会丢失编号可靠信号没有具体对应的名字而是使用了或的方式来表示不可靠信号编号所对应的是不可靠信号信号的处理方式有三种忽略捕捉和默认动作进程对信号的处理函数函数是系统下设置信号处理方式最简单的接口可将信号的处理方式设置为捕获信号忽略信号以及系统默认操作函数指针返回值返回值此函数的返回值也是一个类型的函数指针成功情况下的返回值则是指向在此之前的信号处理函数如果出错则返回并会设置参数介绍此参数指定需要进行设置的信号可使用信号名宏或信号的数字编号建议使用信号名类型的函数指针指向信号对应的信号处理函数当进程接收到信号后会自动执行该处理函数或表示此进程需要忽略该信号则表示设置为系统默认操作函数指针的类型参数指的是当前触发该函数的信号可将多个信号绑定到同一个信号处理函数上此时就可通过此参数来判断当前触发的是哪个信号示例函数将信号绑定到了一个用户自定的处理函数上当进程收到信号后会执行该函数然后运行打印语句当运行程序之后程序会卡在死循环处此时在终端按下中断符系统便会给前台进程组中的每一个进程发送信号我们测试程序便会收到该信号设置信号处理方式死循环注意进程创建当一个进程调用创建子进程时其子进程将会继承父进程的信号处理方式因为子进程在开始时复制了父进程的内存映像所以信号捕获函数的地址在子进程中是有意义的当一个应用程序刚启动的时候或者程序中没有调用函数通常情况下进程对所有信号的处理方式都设置为系统默认操作函数允许单独获取信号的处理函数而不是设置并且还可以设置各种属性对调用信号处理函数时的行为施以更加精准的控制返回值成功返回失败将返回并设置参数介绍需要设置的信号除了信号和信号之外的任何信号指向一个数据结构该数据结构描述了信号的处理方式如果参数为则表示无需改变信号当前的处理方式指向一个数据结构如不为将信号之前的处理方式等信息通过参数返回出来为表示不获取之前信号信息结构体指定信号处理函数与函数的参数相同也用于指定信号处理函数这是一个替代的信号处理函数可以通过该函数获取到更多信息这些信号通过参数获取自行查找资料和是互斥的不能同时设置对于标准信号来说使用就可以了可通过标志进行选择信号掩码可以避免一些信号之间的竞争状态也称为竞态如果设置了该标志则表示使用作为信号处理函数而不是设置为表示使用该成员已过时不要再使用了示例与函数示例的功能相同初始化结构体值为调用保存的函数死循环向进程发送信号与命令相类似系统提供了系统调用一个进程可通过向另一个进程发送信号除了系统调用之外系统还提供了系统调用以及库函数也可用于实现发送信号的功能函数可将信号发送给指定的进程或进程组中的每一个进程返回值成功返回失败将返回并设置参数介绍用于指定接收此信号的进程除此之外参数也可设置为或以及小于等不同值稍后给说明为正则信号将发送到指定的进程等于则将发送到当前进程的进程组中的每个进程等于则将发送到当前进程有权发送信号的每个进程但进程除外小于则将发送到为的进程组中的每个进程指定需要发送的信号设置为表示不发送信号但任执行错误检查这通常可用于检查参数指定的进程是否存在如果向一个不存在的进程发送信号将会返回将被设置表示进程不存在注意进程发送信号给另外一个进程需要权限超级用户进程可以将信号发送给任何进程非超级用户普通用户进程来说其基本规则是发送者进程的实际用户或有效用户必须等于接收者进程的实际用户或有效用户示例函数的示例代码用于接收该信号判断传参个数将传入的字符串转为整形数字向指定的进程发送信号接收信号进程挂后台运行进程号为给进程发信号接收进程的打印函数用于进程向自身发送信号等价于返回值成功返回失败将返回非零值参数介绍为需要发送的信号示例信号处理函数向自身发送信号每隔秒发送一次和函数函数使用函数可以设置一个定时器闹钟当定时器定时时间到时内核会向进程发送信号补充信号的系统默认操作是终止进程返回值如果在调用时之前已经为该进程设置了闹钟还没有超时则该闹钟的剩余值作为本次函数调用的返回值之前设置的闹钟则被新的替代否则返回设置定时时间以秒为单位如果参数等于则表示取消之前设置的闹钟注意闹钟并不能循环触发只能触发一次若想要实现循环触发可以在信号处理函数中再次调用函数设置定时器示例检验传参个数为信号绑定处理函数启动定时器定时时长秒循环定时时长秒函数系统调用可以使得进程暂停运行进入休眠状态直到进程捕获到一个信号为止只有执行了信号处理函数并从其返回时才返回在这种情况下返回并且将设置为示例通过和函数模拟功能检验传参个数为信号绑定处理函数启动定时器定时时长秒进入休眠状态休眠结束定时时长秒休眠结束信号集一个能表示多个信号一组信号的数据类型信号集很多系统调用都使用到了信号集这种数据类型来作为参数传递譬如函数函数函数等信号集其实就是类型数据结构使用这个结构体可以表示一组信号将多个信号添加到该数据结构中当然系统封装了用于操作信号集的譬如初始化信号集初始化信号集使其不包含任何信号初始化信号集使其包含所有信号包括所有实时信号返回值成功返回失败将返回并设置指向需要进行初始化的信号集变量示例初始化为空信号集初始化信号集使其包含所有信号向信号集中添加删除信号向信号集中添加信号向信号集中移除信号返回值成功返回失败将返回并设置指向信号集需要添加删除的信号示例添加信号移除信号测试信号是否在信号集中可以测试某一个信号是否在指定的信号集中返回值如果信号在信号集中则返回如果不在信号集中则返回失败则返回并设置指定信号集需要进行测试的信号示例判断信号是否在信号集中信号集中包含信号信号集中不包含信号获取信号描述信息在下每个信号都有一串与之相对应的字符串描述信息用于对该信号进行相应的描述这些字符串位于数组中数组是一个类型的数组数组中的每一个元素存放的是一个字符串指针指向一个信号描述信息譬如可以使用来获取对信号的描述使用数组需要包含头文件补充在某些较新的系统或者不同的编译环境下可能不能直接可用描述信息描述信息描述信息函数用来获取信号的描述字符串推荐使用这种方案返回值信号描述信息字符串的指针函数会对参数进行检查若传入的无效则会返回信息指定信号示例描述信息描述信息描述信息编号为的描述信息描述信息描述信息描述信息编号为的描述信息函数可以在标准错误上输出信号描述信息补充不存在缓冲区也就是说的输出内容会直接打印在屏幕上指定信号调用者需要添加的一些输出信息示例信号描述信息信号描述信息信号描述信息信号描述信息信号描述信息信号描述信息信号掩码内核为每一个进程维护了一个信号掩码其实就是一个信号集即一组信号当进程接收到一个属于信号掩码中定义的信号时内核会将该信号进行阻塞导致无法传递给进程进行处理直到该信号从信号掩码中移除内核才会把该信号传递给进程从而得到处理注只是将该信号阻塞并不是删除该信号了可以理解为把信号堵在管道里了当从信号掩码中移除信号时该信号又就能出来了向信号掩码中添加一个信号通常有如下几种方式当应用程序调用或函数为某一个信号设置处理方式时进程会自动将该信号添加到信号掩码中这样保证了在处理一个给定的信号时如果此信号再次发生那么它将会被阻塞当然对于而言是否会如此需要根据函数是否设置了标志而定当信号处理函数结束返回后会自动将该信号从信号掩码中移除使用函数为信号设置处理方式时可以额外指定一组信号当调用信号处理函数时将该组信号自动添加到信号掩码中当信号处理函数结束返回后再将这组信号从信号掩码中移除通过参数进行设置除了以上两种方式之外还可以使用系统调用随时可以显式地向信号掩码中添加移除信号向信号掩码中添加移除信号返回值返回值成功返回失败将返回并设置参数介绍指定了调用函数时的一些行为将参数所指向的信号集内的所有信号添加到进程的信号掩码中换言之将信号掩码设置为当前值与的并集将参数指向的信号集内的所有信号从进程信号掩码中移除进程信号掩码直接设置为参数指向的信号集指向的信号集内的所有信号添加到信号掩码中或者从信号掩码中移除如果参数为则表示无需对当前信号掩码作出改动如果参数不为在向信号掩码中添加新的信号之前获取到进程当前的信号掩码存放在所指定的信号集中如果为则表示不获取当前的信号掩码示例由于将信号加入了信号掩码不会立马执行信号处理函数打印执行信号处理函数而是睡眠秒后在休眠结束后打印执行信号处理函数执行信号处理函数注册信号处理函数信号集初始化向信号掩码中添加信号向自己发送信号休眠秒休眠结束从信号掩码中移除添加的信号休眠结束执行信号处理函数阻塞等待信号将恢复信号掩码和挂起进程这两个动作封装成一个原子操作补充原子操作就是两个操作是在一起执行的不会被打断返回值始终返回并设置来指示错误通常为表示被信号所中断如果调用失败将设置为参数指向一个信号集示例执行信号处理函数信号集初始化注册信号处理函数向信号掩码中添加信号执行保护代码段执行保护代码段挂起等待信号唤醒信号掩码被替替换为空恢复信号掩码在上述代码中我们希望执行受保护代码段时不被中断信号打断所以在执行保护代码段之前将信号添加到进程的信号掩码中执行完受保护的代码段之后调用挂起进程等待被信号唤醒被唤醒之后再解除信号的阻塞状态实时性信号内核定义了个不同的实时信号信号编号范围为使用表示编号最小的实时信号使用表示编号最大的实时信号其它信号编号可使用这两个宏加上一个整数或减去一个整数函数当接收到的信号是在信号掩码中时会被阻塞此时信号被添加到进程的等待信号集等待被处理处于等待状态的信号中返回值成功返回失败将返回并设置处于等待状态的信号会存放在参数所指向的信号集中示例补充此函数用于检查一个指定的信号是否在给定的信号集中也就是检查该信号是否被阻塞定义信号集将信号集初始化为空获取当前处于等待状态的信号判断信号是否处于等待状态信号处于等待状态信号未处于等待状态发送实时信号如果同一个信号在阻塞状态下产生了多次那么会将该信号记录在等待信号集中并在之后仅传递一次仅当做发生了一次这是标准信号的缺点之一实时信号较之于标准信号其优势如下实时信号的信号范围有所扩大可应用于应用程序自定义的目的而标准信号仅提供了两个信号可用于应用程序自定义使用和内核对于实时信号所采取的是队列化管理如果将某一实时信号多次发送给另一个进程那么将会多次传递此信号当发送一个实时信号时可为信号指定伴随数据一整形数据或者指针值供接收信号的进程在它的信号处理函数中获取信号传递顺序得到保障信号的编号越小其优先级越高如果是同一类型的多个信号在排队那么信号以及伴随数据的传递顺序与信号发送来时的顺序保持一致应用程序当中使用实时信号需要有以下的两点要求发送进程使用系统调用发送信号及伴随数据接收进程使用函数为信号建立处理函数并且使用而不是可以使用但是获取不到伴随数据了返回值成功将返回失败将返回并设置参数介绍指定接收信号的进程对应的将信号发送给该进程指定需要发送的信号与函数一样也可将参数设置为用于检查参数所指定的进程是否存在参数指定了信号的伴随数据数据类型数据类型共用体如下所示示例发送进程使用系统调用向另一个进程发送实时信号判断传参个数获取用户传递的参数接收进程发送的信号发送信号伴随数据信号发送成功接收到实时信号伴随数据为判断传参个数获取用户传递的参数接收的信号为实时信号绑定处理函数死循环先运行接收进程并且设置接收的信号为然后查看接收程序的使用发送进程向该发送信号接收到实时信号伴随数据为信号发送成功异常退出函数进程异常退出使用终止进程运行会生成核心转储文件可用于判断程序调用时的程序状态当调用函数之后内核会向进程发送信号信号的系统默认操作是终止进程运行并生成核心转储文件示例接收到信号调用接收到信号已中止核心已转储从打印信息可知即使在我们的程序当中捕获了信号但是程序依然会无情的终止无论阻塞或忽略信号调用均不收到影响总会成功终止进程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-04 16:33:13',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://img2.imgtp.com/2024/04/29/XJZajStb.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Ten-zzZ</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/"><span> 音乐馆</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://img2.imgtp.com/2024/04/29/ZLUmR1ch.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://img2.imgtp.com/2024/04/29/ZLUmR1ch.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://img2.imgtp.com/2024/04/29/jhBLTmH3.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://img2.imgtp.com/2024/04/29/jhBLTmH3.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/FreeRTOS/" style="font-size: 1.05rem;">FreeRTOS<sup>1</sup></a><a href="/tags/STM32/" style="font-size: 1.05rem;">STM32<sup>2</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>8</sup></a><a href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 1.05rem;">单片机<sup>2</sup></a><a href="/tags/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/" style="font-size: 1.05rem;">实战项目<sup>1</sup></a><a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" style="font-size: 1.05rem;">嵌入式<sup>3</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">线程<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 1.05rem;">网络编程<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>1</sup></a><a href="/tags/%E8%BF%9B%E7%A8%8B/" style="font-size: 1.05rem;">进程<sup>2</sup></a><a href="/tags/%E9%80%9A%E4%BF%A1/" style="font-size: 1.05rem;">通信<sup>1</sup></a><a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 1.05rem;">随笔<sup>2</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url">linux系统编程</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/linux/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>linux</span></a><a class="article-meta__tags" href="/tags/%E9%80%9A%E4%BF%A1/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>通信</span></a></span></div></div><h1 class="post-title" itemprop="name headline">进程间通信</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-04-30T13:12:40.528Z" title="发表于 2024-04-30 21:12:40">2024-04-30</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-05-04T08:33:13.412Z" title="更新于 2024-05-04 16:33:13">2024-05-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">11.1k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>42分钟</span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为新余"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>新余</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://img2.imgtp.com/2024/04/30/9GnvXoDg.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2024/04/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"><header><a class="post-meta-categories" href="/categories/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url">linux系统编程</a><a href="/tags/linux/" tabindex="-1" itemprop="url">linux</a><a href="/tags/%E9%80%9A%E4%BF%A1/" tabindex="-1" itemprop="url">通信</a><h1 id="CrawlerTitle" itemprop="name headline">进程间通信</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Ten</span><time itemprop="dateCreated datePublished" datetime="2024-04-30T13:12:40.528Z" title="发表于 2024-04-30 21:12:40">2024-04-30</time><time itemprop="dateCreated datePublished" datetime="2024-05-04T08:33:13.412Z" title="更新于 2024-05-04 16:33:13">2024-05-04</time></header><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>进程间通信（interprocess communication，简称 IPC） 指两个进程之间的通信。 系统中的每一个进程都有<br>各自的地址空间，并且相互独立、隔离， 每个进程都处于自己的地址空间中。 所以同一个进程的不同模块（譬如不同的函数）之间进行通信都是很简单的，譬如使用全局变量等。但是，两个不同的进程之间要进行通信通常是比较难的，因为这两个进程处于不同的地址空间中；通常情况下，大部分的程序是不要考虑进程间通信的，因为大家所接触绝大部分程序都是单进程程序（可以有多个线程），对于一些复杂、大型的应用程序，则会根据实际需要将其设计成多进程程序，譬如 GUI、服务区应用程序等  。</p>
<p>进程间通信通常有：管道，消息队列，信号量，共享内存，socket，streams。其中socket和streams支持两个不同主机间的进程通信</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>把一个进程连接到另一个进程的数据流称为管道，管道被抽象成一个文件，这种文件叫管道文件，都是该文件不属于如何文件系统。管道分为匿名管道和命名管道</p>
<h3 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h3><p><strong>匿名管道的特点</strong>：也称为无名管道，是最常用的管道</p>
<ul>
<li>半双工，同一时间只能由一端传送给另一端</li>
<li>只能在父子或者兄弟进程间使用  </li>
<li>管道的本质是文件，管道文件不属于任何文件系统</li>
</ul>
<p><strong>pipe()：用于创建一个匿名管道</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>

<p>返回值：成功返回0，失败返回-1，并且设置errno。</p>
<p>参数介绍：</p>
<ul>
<li>fd为文件描述符数组，其中<code>fd[0]</code>表示读端，<code>fd[1]</code> 表示写端</li>
</ul>
<p><strong>父子进程通信过程解析</strong></p>
<ol>
<li>父进程创建管道，得到两个文件描述符指向管道的两端；</li>
<li>父进程fork出子进程，子进程也有两个文件描述符指向同一个管道。</li>
<li>父进程关闭<code>fd[0]（读端）</code>,子进程关闭<code>fd[1]（写端）</code>，因为管道只支持单向通信。（也可父写子读）</li>
</ol>
<p><strong>示例：</strong>子进程写数据，父进程读数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">if</span>(pipe(fd)==<span class="number">-1</span>)	<span class="comment">//创建管道</span></span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	pid = fork();		<span class="comment">//创建子进程</span></span><br><span class="line">	<span class="keyword">switch</span>(pid)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">			perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:			<span class="comment">//子进程写数据，父进程读数据</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;我是子进程\r\n&quot;</span>);</span><br><span class="line">			close(fd[<span class="number">0</span>]);		<span class="comment">//关闭读功能</span></span><br><span class="line">			write(fd[<span class="number">1</span>],<span class="string">&quot;hello father&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;hello father&quot;</span>));</span><br><span class="line">			_exit(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下是父进程执行的内容</span></span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;我是父进程\r\n&quot;</span>);</span><br><span class="line">	close(fd[<span class="number">1</span>]);		<span class="comment">//关闭写功能</span></span><br><span class="line">	read(fd[<span class="number">0</span>],buf,<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;read from child: %s\r\n&quot;</span>,buf);</span><br><span class="line">	wait(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ten@ten-virtual-machine:~/H616/demo$ ./sig</span><br><span class="line">我是子进程</span><br><span class="line">我是父进程</span><br><span class="line">read from child: hello father</span><br></pre></td></tr></table></figure>

<h3 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h3><p>不同于匿名管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存储于文件系统中。说白了就是命名管道会以文件存储在系统中。</p>
<p><strong>命名管道特征：</strong></p>
<ol>
<li>可以进行不相干进程间的通信</li>
<li>命名管道是一个文件，对于文件的相关操作对其同样适用</li>
<li>对于管道文件，当前进程操作为只读时，则进行阻塞，直至有进程对其写入数据</li>
<li>对于管道文件，当前进程操作为只写时，则进行阻塞，直至有进程从管道中读取数据</li>
</ol>
<p><strong>mkfifo()：</strong>用于创建一个命名管道</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path,<span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值：成功都返回0，失败都返回－1，并会设置errno。</p>
<p>参数介绍：</p>
<ul>
<li>path：创建的命名管道的全路径名</li>
<li>mode：指定了文件的读写权限</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>命名管道和匿名管道的使用方法法基本是相同的。只是使用命名管道时，必须先调用<code>open()</code>将其打开。因为命名管道是一个存在于硬盘上的文件，而匿名管道是存在于内存中的特殊文件。</li>
<li>调用open()打开命名管道的进程可能会被阻塞。<ul>
<li>但如果同时用读写方式（ O_RDWR）打开，则一定不会导致阻塞</li>
<li>如果以只读方式（ O_RDONLY）打开，则调用open()函数的进程将会被阻塞直到有写方打开管道；</li>
<li>同样以只写方式（ O_WRONLY）打开也会阻塞直到有读方式打开管道。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端，读数据的进程</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    umask(<span class="number">0</span>);<span class="comment">//将权限清0</span></span><br><span class="line">    <span class="keyword">if</span>(mkfifo(<span class="string">&quot;./file&quot;</span>,<span class="number">0666</span>|S_IFIFO)==<span class="number">-1</span> &amp;&amp; errno!=EEXIST)&#123;<span class="comment">//创建管道</span></span><br><span class="line">        perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./file&quot;</span>,O_RDONLY);<span class="comment">//打开管道</span></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请等待。。。\n&quot;</span>);</span><br><span class="line">        <span class="type">ssize_t</span> s = read(fd,buf,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            buf[s<span class="number">-1</span>] = <span class="number">0</span>;<span class="comment">//过滤\n</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器：%s\n&quot;</span>,buf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="number">0</span>)&#123;<span class="comment">//当客户端退出时，read返回0</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端退出，自己退出\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端，写数据的进程</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./file&quot;</span>,O_WRONLY);<span class="comment">//打开管道</span></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端：&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="type">ssize_t</span> s = read(<span class="number">0</span>,buf,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>);<span class="comment">//向管道文件中写数据</span></span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            buf[s] = <span class="number">0</span>;<span class="comment">//以字符串的形式写</span></span><br><span class="line">            write(fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20240501131819514.png" alt="image-20240501131819514"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20240501131831187.png" alt="image-20240501131831187"></p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</p>
<p><strong>消息队列特点：</strong></p>
<ol>
<li>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</li>
<li>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</li>
<li>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取</li>
</ol>
<p><strong>头文件</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>ftok()</strong></p>
<p>系统建立IPC通讯（如消息队列、共享内存时）必须指定一个ID值。通常情况下，该id值通过ftok函数得到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值：当成功执行的时候，一个key_t值将会被返回，否则 -1 被返回。</p>
<p>参数介绍：</p>
<ul>
<li>pathname：传入一个路径（一般是当前路径“ . ”）。</li>
<li>proj_id：随便填写一个数（要做通信的话通信的另外一端要与这个数保持一致才能找到对应的icpID）。</li>
</ul>
<h4 id="创建或打开消息队列："><a href="#创建或打开消息队列：" class="headerlink" title="创建或打开消息队列："></a><strong>创建或打开消息队列：</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> flag)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值：成功返回队列ID，失败返回-1。</p>
<p>参数介绍：</p>
<ul>
<li>key：key是一个键值，由ftok获得。通信双方要想通信，key值要一样。</li>
<li>flag：标识函数的行为以及消息队列的权限<ul>
<li>IPC_CREAT：创建消息队列</li>
<li>IPC_EXCL：检测消息队列是否存在 </li>
<li>位或权限位：消息队列位或权限位后可以设置消息队列的访问权限，格式和open函数的mode_t一样，但可执行权限未使用</li>
</ul>
</li>
</ul>
<h4 id="添加消息"><a href="#添加消息" class="headerlink" title="添加消息"></a><strong>添加消息</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">int</span> flag)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值：成功返回0，失败返回-1。</p>
<p>参数介绍：</p>
<ul>
<li><p>msqid：消息对象ID。</p>
</li>
<li><p>ptr：要是的消息的结构体变量的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 消息结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;		<span class="comment">//消息的类型</span></span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">256</span>];	<span class="comment">//消息的内容</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>size：消息正文的字节数（等于消息结构体的大小减去long类型的大小）</p>
</li>
<li><p>flag：0：msgsnd调用阻塞直到条件满足为止；IPC_NOWAIT：若消息没有立刻发送则调用该函数的进程会立刻返回</p>
</li>
</ul>
<h4 id="读取消息"><a href="#读取消息" class="headerlink" title="读取消息"></a><strong>读取消息</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">long</span> type,<span class="type">int</span> flag)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值：成功返回消息数据的长度，失败返回-1</p>
<p>参数介绍：</p>
<ul>
<li>msqid：消息队列的标识符，代表要从哪个消息队列中获取消息</li>
<li>ptr：存放消息的结构体地址</li>
<li>size：消息正文的字节数</li>
<li>type：感兴趣的消息类型，可以有以下几种类型<ul>
<li>type&#x3D;0：返回队列中第一个消息</li>
<li>type&gt;0：返回队列中消息类型为type的消息</li>
<li>type&lt;0：返回队列中消息类型小于等于msgtyp的绝对值的消息，如果这种消息有若干个，则取类型值最小的消息</li>
</ul>
</li>
<li>flag：函数的控制属性<ul>
<li>0：msgrcv调用阻塞直到接收消息成功为止</li>
<li>MSG_NOERROR：若返回的消息字节数比nbytes字节数多，则消息就会截断到nbytes字节，且不通知消息发送进程；</li>
<li>IPC_NOWAIT：调用进程会立即返回，若没有收到消息则立即返回-1</li>
</ul>
</li>
</ul>
<h4 id="消息队列的控制"><a href="#消息队列的控制" class="headerlink" title="消息队列的控制"></a><strong>消息队列的控制</strong></h4><p>对消息队列进行各种控制，如删除消息队列，修改消息队列的属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int msgctl(int msqid, int cmd, struct msqid_ds *buf);</span><br></pre></td></tr></table></figure>

<p>返回值：成功返回0，失败返回-1。</p>
<p>参数介绍：</p>
<ul>
<li>msqid：消息队列的标识符 c</li>
<li>md：函数功能的控制 <ul>
<li>IPC_RMID：删除由msqid标识的消息队列，将他从系统中删除并破坏相关的数据结</li>
<li>IPC_STAT：将msqid相关的数据结构中各个元素的当前值存入到由buf指向的结构中 IPC_SET</li>
<li>将msqid相关的数据结构中的元素设置为由buf指向的结构中的对应值</li>
</ul>
</li>
<li>buf：msqid_ds数据类型的地址，用来存放或更改消息队列的属性</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">							<span class="comment">/*进程A*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 消息结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;     <span class="comment">//消息的类型</span></span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">128</span>];    <span class="comment">//消息的内容</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    key = ftok(<span class="string">&quot;.&quot;</span>,<span class="string">&#x27;z&#x27;</span>);	</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key=%x\r\n&quot;</span>,key);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> msgid = msgget(key,IPC_CREAT|<span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == msgid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msgget error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中读取消息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">readBuf</span>;</span></span><br><span class="line">    msgrcv(msgid,&amp;readBuf,<span class="keyword">sizeof</span>(readBuf.mtext),<span class="number">888</span>,<span class="number">0</span>);	<span class="comment">//读取类型为888的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read from Que:%s\r\n&quot;</span>,readBuf.mtext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送消息道队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">sendBuf</span> =</span> &#123;<span class="number">888</span>,<span class="string">&quot;我是进程A&quot;</span>&#125;;	</span><br><span class="line">    msgsnd(msgid,&amp;sendBuf,<span class="built_in">strlen</span>(sendBuf.mtext),<span class="number">0</span>);	<span class="comment">//发送类型为888的数据</span></span><br><span class="line">     </span><br><span class="line">     msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);	<span class="comment">//删除消息队列</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> 								<span class="comment">/*进程B*/</span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;     <span class="comment">//消息的类型</span></span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">128</span>];    <span class="comment">//消息的内容</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    key = ftok(<span class="string">&quot;.&quot;</span>,<span class="string">&#x27;z&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key=%x\r\n&quot;</span>,key);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> msgid = msgget(key,IPC_CREAT|<span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == msgid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msgget error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送消息道队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">sendBuf</span> =</span> &#123;<span class="number">888</span>,<span class="string">&quot;我是进程B&quot;</span>&#125;;</span><br><span class="line">    msgsnd(msgid,&amp;sendBuf,<span class="built_in">strlen</span>(sendBuf.mtext),<span class="number">0</span>);	<span class="comment">//发送类型为888的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中读取消息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">readBuf</span>;</span></span><br><span class="line">    msgrcv(msgid,&amp;readBuf,<span class="keyword">sizeof</span>(readBuf.mtext),<span class="number">888</span>,<span class="number">0</span>);	<span class="comment">//读取类型为888的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read from Que:%s\r\n&quot;</span>,readBuf.mtext);</span><br><span class="line">    </span><br><span class="line">    msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);	<span class="comment">//删除消息队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20240501160122183.png" alt="image-20240501160122183"></p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存就是映射一段能被其它进程所访问的内存， 这段共享内存由一个进程创建， 但其它的多个进程<br>都可以访问， 使得多个进程可以访问同一块内存空间。共享内存是最快的 IPC 方式， 它是针对其它进程间<br>通信方式运行效率低而专门设计的， 它往往与其它通信机制， 譬如结合信号量来使用， 以实现进程间的同步<br>和通信  </p>
<p>共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。</p>
<p><strong>共享内存特点：</strong></p>
<ol>
<li>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。</li>
<li>因为多个进程可以同时操作，所以需要进行同步。</li>
<li>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</li>
</ol>
<p><strong>共享内存操作步骤</strong>：</p>
<ol>
<li>创建共享内存&#x2F;打开共享内存</li>
<li>连接：连接该共享内存到当前进程的地址空间，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问。</li>
<li>读写数据：</li>
<li>分离：并不是从系统中删除该共享内存，只是当前进程不能再访问该共享内存而已。</li>
<li>销毁：从系统中删除该共享内存。</li>
</ol>
<p><strong>头文件</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="创建或获取——shmget"><a href="#创建或获取——shmget" class="headerlink" title="创建或获取——shmget()"></a><strong>创建或获取——shmget()</strong></h4><p>创建或获取一个共享内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值：成功返回共享内存ID(shmid)，失败返回-1。</p>
<p>参数介绍：</p>
<ul>
<li>key：key是一个键值，由ftok获得。用于唯一标识一块共享内存</li>
<li>size：共享内存大小。而如果引用一个已存在的共享内存，则将 size 指定为0 。</li>
<li>shmflg：该参数用于确定共享内存属性。<code>标志位 | 内存权限</code><ul>
<li>IPC_CREAT；IPC_EXCL</li>
<li>值得注意<code>PC_EXCL</code>无法单独使用</li>
</ul>
</li>
</ul>
<h4 id="连接——shmat"><a href="#连接——shmat" class="headerlink" title="连接——shmat()"></a><strong>连接——shmat</strong>()</h4><p>创建共享内存后还不能直接使用，需要找到内存地址后才能使用，即连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值：连接成功返回共享内存在进程中的起始地址，失败返回-1。</p>
<p>参数介绍：</p>
<ul>
<li>shmid：共享内存ID，即shmget的创建成功的返回值</li>
<li>shmaddr：用于确定将共享内存挂在进程虚拟地址哪个位置，一般填<code>nullptr</code>即可代表让内核自己确定位置。</li>
<li>shmflg：用于确定挂接方式，<code>一般填0</code>。</li>
</ul>
<h4 id="分离——shmdt"><a href="#分离——shmdt" class="headerlink" title="分离——shmdt()"></a><strong>分离——shmdt</strong>()</h4><p>当使用共享内存完毕后，需要分离挂接的共享内存。</p>
<p><code>注意</code>，这并不是从系统中删除该共享内存，只是当前进程不能再访问该共享内存而已。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值：分离成功返回0，失败返回-1。 </p>
<p>参数介绍：</p>
<ul>
<li>shmaddr：为共享内存在进程中地址位置，一般填<code>nullptr</code>。</li>
</ul>
<h4 id="控制——shmctl"><a href="#控制——shmctl" class="headerlink" title="控制——shmctl()"></a><strong>控制——shmctl</strong>()</h4><p>该接口本身用于控制共享内存，可用于销毁。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值：成功返回0，失败返回-1。 </p>
<p>参数介绍：</p>
<ul>
<li>shmid：共享内存ID，即shmget的创建成功的返回值</li>
<li>cmd：函数功能的控制 <ul>
<li>IPC_RMID：销毁由shqid标识的共享内存</li>
<li>···</li>
</ul>
</li>
<li>buf：传nullptr。</li>
</ul>
<p><strong>ipcs</strong>：该指令为系统指令。使用时可以查看当前全部共享内存。<code>ipcs -m </code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20240501173425300.png" alt="image-20240501173425300"></p>
<p><strong>ipcrm</strong>：通过指定共享内存shmid，进行删除。<code>ipcrm -m [shmid] </code></p>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">							<span class="comment">/*进程A*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">char</span> *shmaddr;</span><br><span class="line">    key = ftok(<span class="string">&quot;.&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    shmid = shmget(key,<span class="number">1024</span>,IPC_CREAT|<span class="number">0666</span>);  <span class="comment">//创建共享内存</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==shmid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shmget error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shmaddr = shmat(shmid,<span class="number">0</span>,<span class="number">0</span>);   <span class="comment">//连接映射</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == shmaddr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shmat error\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(shmaddr,<span class="string">&quot;hello world&quot;</span>);  <span class="comment">//往共享内存映射在进程空间中的内存中写数据</span></span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);       <span class="comment">//等待进程B读取完</span></span><br><span class="line">    shmdt(shmaddr);     <span class="comment">//分离</span></span><br><span class="line">    shmctl(shmid,IPC_RMID,<span class="number">0</span>);  <span class="comment">//销毁</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;共享内存已销毁\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">							<span class="comment">/*进程B*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">char</span> *shmaddr;</span><br><span class="line">    key = ftok(<span class="string">&quot;.&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    shmid = shmget(key,<span class="number">1024</span>,<span class="number">0</span>);  <span class="comment">//打开共享内存</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == shmid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shmget error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shmaddr = shmat(shmid,<span class="number">0</span>,<span class="number">0</span>);   <span class="comment">//连接映射</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == shmaddr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shmat error\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read data:%s\r\n&quot;</span>,shmaddr);  <span class="comment">//从共享内存映射在进程空间中的内存中读数据并打印</span></span><br><span class="line"></span><br><span class="line">    shmdt(shmaddr);     <span class="comment">//分离</span></span><br><span class="line">    <span class="comment">// shmctl(shmid,PC_RMID,nullptr);  //销毁，另一个进程A已经销毁</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;共享内存已销毁\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20240501172808957.png" alt="image-20240501172808957"></p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号是事件发生时对进程的通知机制，也可以把它称为软件中断。信号与硬件中断的相似之处在于能够<br>打断程序当前执行的正常流程， 其实是在软件层次上对中断机制的一种模拟。 大多数情况下，是无法预测信<br>号达到的准确时间，所以，信号提供了一种处理异步事件的方法  </p>
<p>信号的目的是用来通信的，用于通知接收信号的进程有某种事件发生，所以可用于进程间通信；除了用于进程间通信之外，进程还可以发送信号给进程本身。  </p>
<h3 id="信号的分类"><a href="#信号的分类" class="headerlink" title="信号的分类"></a>信号的分类</h3><p>linux系统下可以从两个角度对信号进行分类，从可靠性方面将信号分为可靠信号与不可靠信号，从实时性方面将信号分为实时信号与非实时信号。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20240503164227615.png" alt="image-20240503164227615"></p>
<p><strong>可靠信号</strong></p>
<p>可靠信号支持排队，不会丢失。编号34~64，可靠信号没有具体对应的名字，而是使用了 SIGRTMIN+N 或 SIGRTMAXN 的方式来表示  </p>
<p><strong>不可靠信号</strong></p>
<p>编号 1~31 所对应的是不可靠信号  </p>
<p>信号的处理方式有三种：忽略、捕捉和默认动作</p>
<h3 id="进程对信号的处理"><a href="#进程对信号的处理" class="headerlink" title="进程对信号的处理"></a>进程对信号的处理</h3><h4 id="signal-函数"><a href="#signal-函数" class="headerlink" title="signal()函数"></a>signal()函数</h4><p>signal()函数是 Linux 系统下设置信号处理方式最简单的接口， 可将信号的处理方式设置为捕获信号、 忽略信号以及系统默认操作  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sig_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;		<span class="comment">//函数指针</span></span><br><span class="line"><span class="type">sig_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sig_t</span> handler)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>返回值：</strong>返回值： 此函数的返回值也是一个 sig_t 类型的函数指针，成功情况下的返回值则是指向在此之前的信号处理函数；如果出错则返回 SIG_ERR，并会设置 errno。  </p>
<p><strong>参数介绍：</strong></p>
<ul>
<li><p>signum： 此参数指定需要进行设置的信号，可使用信号名（宏）或信号的数字编号，建议使用信号名  </p>
</li>
<li><p>handler： sig_t 类型的函数指针，指向信号对应的信号处理函数，当进程接收到信号后会自动执行该处<br>理函数；  SIG_IGN 或 SIG_DFL， SIG_IGN 表示此进程需要忽略该信号， SIG_DFL 则表示设置为系统默认操作。  </p>
</li>
<li><p>sig_t 函数指针的 int 类型参数指的是，当前触发该函数的信号，可将多个信号绑定到同一个信号处理函数<br>上，此时就可通过此参数来判断当前触发的是哪个信号。</p>
</li>
</ul>
<p><strong>示例</strong>：</p>
<p>signal()函数将 SIGINT（2） 信号绑定到了一个用户自定的处理函数sig_handler(int sig)上， 当进程收到 SIGINT 信号后会执行该函数然后运行 printf 打印语句  。</p>
<p>当运行程序之后，程序会卡在 for 死循环处，此时在终端按下中断符 CTRL + C，系统便会给前台进程组中的每一个进程发送SIGINT 信号，我们测试程序便会收到该信号。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Received signal: %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sig_t</span> ret = <span class="literal">NULL</span>;</span><br><span class="line">    ret = signal(SIGINT, (<span class="type">sig_t</span>)sig_handler);		<span class="comment">//设置信号处理方式</span></span><br><span class="line">    <span class="keyword">if</span> (SIG_ERR == ret)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 死循环 */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ten@ten-virtual-machine:~/H616/demo$ ./sig </span><br><span class="line">^CReceived signal: 2</span><br><span class="line">^CReceived signal: 2</span><br><span class="line">^CReceived signal: 2</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ol>
<li>进程创建 当一个进程调用 fork()创建子进程时，其子进程将会继承父进程的信号处理方式，因为子进程在开始时复制了父进程的内存映像，所以信号捕获函数的地址在子进程中是有意义的。  </li>
<li>当一个应用程序刚启动的时候（或者程序中没有调用 signal()函数） ， 通常情况下， 进程对所有信号的<br>处理方式都设置为系统默认操作。</li>
</ol>
<h4 id="sigaction-函数"><a href="#sigaction-函数" class="headerlink" title="sigaction()函数"></a>sigaction()函数</h4><p>sigaction()允许单独获取信号的处理函数而不是设置，并且还可以设置各种属性对调用信号处理函数时<br>的行为施以更加精准的控制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>返回值</strong>：成功返回 0；失败将返回-1，并设置 errno。  </p>
<p><strong>参数介绍：</strong></p>
<ul>
<li>signum： 需要设置的信号，除了 SIGKILL 信号和 SIGSTOP 信号之外的任何信号。  </li>
<li>act： 指向一个 struct sigaction 数据结构，该数据结构描述了信号的处理方式，如果参数 act 为 NULL，则表示无需改变信号当前的处理方式。  </li>
<li>oldact：指向一个 struct sigaction 数据结构。如oldact 不为 NULL， 将信号之前的处理方式等信息通过参数 oldact 返回出来；为NULL表示不获取之前信号信息。</li>
</ul>
<p>**struct sigaction 结构体  **</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;</span><br><span class="line">    <span class="type">int</span> sa_flags;</span><br><span class="line">    <span class="type">void</span> (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>sa_handler：指定信号处理函数，与 signal()函数的 handler 参数相同。</li>
<li>sa_sigaction：也用于指定信号处理函数，这是一个替代的信号处理函数，可以通过该函数获取到更多信息，这些信号通过 siginfo_t 参数获取（自行查找资料）；<code> sa_handler 和sa_sigaction 是互斥的</code>，不能同时设置， 对于标准信号来说， 使用 sa_handler 就可以了，可通过SA_SIGINFO 标志进行选择  </li>
<li>sa_mask：信号掩码可以避免一些信号之间的竞争状态（也称为竞态）。</li>
<li>sa_flags：SA_SIGINFO如果设置了该标志，则表示使用 sa_sigaction 作为信号处理函数、而不是 sa_handler，设置为0表示使用sa_handler。</li>
<li>sa_restorer：该成员已过时，不要再使用了。</li>
</ul>
<p><strong>示例</strong>：与signal()函数示例的功能相同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Received signal: %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;		<span class="comment">//初始化结构体</span></span><br><span class="line">    sig.sa_handler = sig_handler;</span><br><span class="line">    sig.sa_flags = <span class="number">0</span>;				<span class="comment">//值为0，调用sa_handler保存的函数</span></span><br><span class="line">    ret = sigaction(SIGINT, &amp;sig, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line">    perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 死循环 */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="向进程发送信号"><a href="#向进程发送信号" class="headerlink" title="向进程发送信号"></a>向进程发送信号</h3><p>与 kill 命令相类似， Linux 系统提供了 kill()系统调用，一个进程可通过 kill()向另一个进程发送信号；<br>除了 kill()系统调用之外， Linux 系统还提供了系统调用 killpg()以及库函数 raise()，也可用于实现发送信号<br>的功能 。</p>
<h4 id="kill-函数"><a href="#kill-函数" class="headerlink" title="kill()函数"></a>kill()函数</h4><p>可将信号发送给指定的进程或进程组中的每一个进程  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>返回值</strong>：成功返回 0；失败将返回-1，并设置 errno。  </p>
<p><strong>参数介绍：</strong></p>
<ul>
<li>pid：用于指定接收此信号的进程 pid；除此之外，参数 pid 也可设置为 0 或-1 以及小于-1 等不同值，稍后给说明  <ul>
<li>pid为正：则信号 sig 将发送到 pid 指定的进程  </li>
<li>pid等于0：则将 sig 发送到当前进程的进程组中的每个进程。  </li>
<li>pid等于-1：则将 sig 发送到当前进程有权发送信号的每个进程，但进程 1（init）除外。  </li>
<li>pid 小于-1，则将 sig 发送到 ID 为-pid 的进程组中的每个进程。</li>
</ul>
</li>
<li>sig： 指定需要发送的信号，设置为 0表示不发送信号，但任执行错误检查，这通常可用于检查参数 pid 指定的进程是否存在。  如果向一个不存在的进程发送信号， kill()将会返回-1， errno 将被设置ESRCH，表示进程不存在</li>
</ul>
<p><strong>注意</strong>：进程发送信号给另外一个进程需要权限</p>
<ul>
<li>超级用户root 进程可以将信号发送给任何进程</li>
<li>非超级用户（普通用户）进程来说，其基本规则是发送者进程的实际用户 ID 或有效用户 ID 必须等于接收者进程的实际用户 ID 或有效用户 ID</li>
</ul>
<p><strong>示例</strong>： sigaction()函数的示例代码用于接收该信号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="comment">/* 判断传参个数 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> &gt; argc)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">/* 将传入的字符串转为整形数字 */</span></span><br><span class="line">    pid = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid: %d\n&quot;</span>, pid);</span><br><span class="line">    <span class="comment">/* 向 pid 指定的进程发送信号 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == kill(pid, SIGINT)) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;kill error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ten@ten-virtual-machine:~/H616/demo$ ./testApp &amp;	#接收信号进程挂后台运行，进程号为8879</span><br><span class="line">[1] 8879</span><br><span class="line">ten@ten-virtual-machine:~/H616/demo$ ./testApp2 8879	#给8879进程发信号</span><br><span class="line">pid: 8879</span><br><span class="line">Received signal: 2										#接收进程的打印</span><br></pre></td></tr></table></figure>

<h4 id="raise-函数"><a href="#raise-函数" class="headerlink" title="raise()函数"></a>raise()函数</h4><p>用于进程向自身发送信号，raise(sig)等价于kill(getpid(), sig);  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>返回值：</strong> 成功返回 0；失败将返回非零值。  </p>
<p><strong>参数介绍</strong>：sig 为需要发送的信号。  </p>
<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Received signal: %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    sig.sa_handler = sig_handler;</span><br><span class="line">    sig.sa_flags = <span class="number">0</span>;</span><br><span class="line">    ret = sigaction(SIGINT, &amp;sig, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 向自身发送 SIGINT 信号 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != raise(SIGINT)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;raise error\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    	sleep(<span class="number">3</span>); <span class="comment">// 每隔 3 秒发送一次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ten@ten-virtual-machine:~/H616/demo$ ./sig </span><br><span class="line">Received signal: 2</span><br><span class="line">Received signal: 2</span><br><span class="line">Received signal: 2</span><br></pre></td></tr></table></figure>

<h3 id="alarm-和-pause-函数"><a href="#alarm-和-pause-函数" class="headerlink" title="alarm()和 pause()函数"></a>alarm()和 pause()函数</h3><h4 id="alarm-函数"><a href="#alarm-函数" class="headerlink" title="alarm()函数"></a>alarm()函数</h4><p>使用 alarm()函数可以设置一个定时器（闹钟） ，当定时器定时时间到时，内核会向进程发送 <code>SIGALRM</code><br>信号  。<code>补充</code>:SIGALRM 信号的系统默认操作是终止进程  。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>返回值：</strong> 如果在调用 alarm()时，之前已经为该进程设置了 alarm 闹钟还没有超时，则该闹钟的剩余值作为本次 alarm()函数调用的返回值，之前设置的闹钟则被新的替代；否则返回 0。  </p>
<p><strong>seconds：</strong> 设置定时时间，以秒为单位；如果参数 seconds 等于 0，则表示取消之前设置的 alarm 闹钟。  </p>
<p><strong>注意</strong>： alarm 闹钟并不能循环触发，只能触发一次，若想要实现循环触发，可以在 SIGALRM 信号处理函数中再次调用 alarm()函数设置定时器。  </p>
<p><strong>示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Alarm timeout&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> second;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 检验传参个数 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> &gt; argc)</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 为 SIGALRM 信号绑定处理函数 */</span></span><br><span class="line">    sig.sa_handler = sig_handler;</span><br><span class="line">    sig.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == sigaction(SIGALRM, &amp;sig, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/* 启动 alarm 定时器 */</span></span><br><span class="line">    second = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定时时长: %d 秒\n&quot;</span>, second);</span><br><span class="line">    alarm(second);</span><br><span class="line">    <span class="comment">/* 循环 */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ten@ten-virtual-machine:~/H616/demo$ ./sig 5</span><br><span class="line">定时时长: 5 秒</span><br><span class="line">Alarm timeout</span><br></pre></td></tr></table></figure>

<h4 id="pause-函数"><a href="#pause-函数" class="headerlink" title="pause()函数"></a>pause()函数</h4><p>pause()系统调用可以使得进程暂停运行、进入休眠状态，直到进程捕获到一个信号为止，只有执行了信<br>号处理函数并从其返回时， pause()才返回，在这种情况下， pause()返回-1，并且将 errno 设置为 EINTR。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong>通过 alarm()和 pause()函数模拟 sleep 功能。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;  </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Alarm timeout&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> second;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 检验传参个数 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> &gt; argc)</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    	</span><br><span class="line">    <span class="comment">/* 为 SIGALRM 信号绑定处理函数 */</span></span><br><span class="line">    sig.sa_handler = sig_handler;</span><br><span class="line">    sig.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == sigaction(SIGALRM, &amp;sig, <span class="literal">NULL</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 启动 alarm 定时器 */</span></span><br><span class="line">    second = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定时时长: %d 秒\n&quot;</span>, second);</span><br><span class="line">    alarm(second);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 进入休眠状态 */</span></span><br><span class="line">    pause();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;休眠结束&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ten@ten-virtual-machine:~/H616/demo$ ./sig 3</span><br><span class="line">定时时长: 3 秒</span><br><span class="line">Alarm timeout</span><br><span class="line">休眠结束</span><br></pre></td></tr></table></figure>

<h3 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h3><p>一个能表示多个信号（一组信号）的数据类型—信号集（signal set），很多系统调用都<br>使用到了信号集这种数据类型来作为参数传递，譬如 sigaction()函数、 sigprocmask()函数、 sigpending()函数<br>等。  </p>
<p>信号集其实就是 sigset_t 类型数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _SIGSET_NWORDS (1024 / (8 * sizeof (unsigned long int)))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __val[_SIGSET_NWORDS];</span><br><span class="line">&#125; <span class="type">sigset_t</span>;</span><br></pre></td></tr></table></figure>

<p>使用这个结构体可以表示一组信号，将多个信号添加到该数据结构中， 当然 Linux 系统封装了用于操作<br>sigset_t 信号集的 API，譬如 sigemptyset()、 sigfillset()、 sigaddset()、 sigdelset()、 sigismember()。 </p>
<h4 id="初始化信号集"><a href="#初始化信号集" class="headerlink" title="初始化信号集"></a>初始化信号集</h4><p><strong>sigemptyset()：</strong>初始化信号集，使其不包含任何信号</p>
<p>**sigfillset()**：初始化信号集，使其包含所有信号（包括所有实时信号）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>返回值：</strong> 成功返回 0；失败将返回-1，并设置 errno  。</p>
<p><strong>set：</strong> 指向需要进行初始化的信号集变量。</p>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化为空信号集</span></span><br><span class="line"><span class="type">sigset_t</span> sig_set;</span><br><span class="line">sigemptyset(&amp;sig_set);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化信号集，使其包含所有信号：</span></span><br><span class="line"><span class="type">sigset_t</span> sig_set;</span><br><span class="line">sigfillset(&amp;sig_set);</span><br></pre></td></tr></table></figure>

<h4 id="向信号集中添加-删除信号"><a href="#向信号集中添加-删除信号" class="headerlink" title="向信号集中添加&#x2F;删除信号"></a>向信号集中添加&#x2F;删除信号</h4><p><strong>sigaddset()：</strong>向信号集中添加信号</p>
<p><strong>sigdelset()：</strong>向信号集中移除信号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>返回值：</strong> 成功返回 0；失败将返回-1，并设置 errno。  </p>
<p><strong>set：</strong> 指向信号集。  </p>
<p><strong>signum：</strong> 需要添加&#x2F;删除的信号。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加信号</span></span><br><span class="line"><span class="type">sigset_t</span> sig_set;</span><br><span class="line">sigemptyset(&amp;sig_set);</span><br><span class="line">sigaddset(&amp;sig_set, SIGINT);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除信号</span></span><br><span class="line"><span class="type">sigset_t</span> sig_set;</span><br><span class="line">sigfillset(&amp;sig_set);</span><br><span class="line">sigdelset(&amp;sig_set, SIGINT);</span><br></pre></td></tr></table></figure>

<h3 id="测试信号是否在信号集中"><a href="#测试信号是否在信号集中" class="headerlink" title="测试信号是否在信号集中"></a>测试信号是否在信号集中</h3><p><strong>sigismember()：</strong>可以测试某一个信号是否在指定的信号集中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>返回值：</strong> 如果信号 signum 在信号集 set 中，则返回 1；如果不在信号集 set 中，则返回 0；失败则返回-<br>1，并设置 errno。  </p>
<p><strong>set：</strong> 指定信号集  </p>
<p><strong>signum：</strong> 需要进行测试的信号。  </p>
<p><strong>示例：</strong>判断 SIGINT 信号是否在 sig_set 信号集中  。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> sig_set;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> == sigismember(&amp;sig_set, SIGINT))</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;信号集中包含 SIGINT 信号&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!sigismember(&amp;sig_set, SIGINT))</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;信号集中不包含 SIGINT 信号&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="获取信号描述信息"><a href="#获取信号描述信息" class="headerlink" title="获取信号描述信息"></a>获取信号描述信息</h4><p>在 Linux 下，每个信号都有一串与之相对应的字符串描述信息，用于对该信号进行相应的描述。这些字<br>符串位于 sys_siglist 数组中， sys_siglist 数组是一个 char *类型的数组，数组中的每一个元素存放的是一个字<br>符串指针，指向一个信号描述信息。譬如，可以使用 sys_siglist[SIGINT]来获取对 SIGINT 信号的描述。  </p>
<p><code>Tips</code>：使用 sys_siglist 数组需要包含&lt;signal.h&gt;头文件  </p>
<p><code>补充</code>：在某些较新的系统或者不同的编译环境下，<code>sys_siglist</code> 可能不能直接可用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 描述信息: %s\n&quot;</span>, sys_siglist[SIGINT]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 描述信息: %s\n&quot;</span>, sys_siglist[SIGQUIT]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGBUS 描述信息: %s\n&quot;</span>, sys_siglist[SIGBUS]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20240503203542689.png" alt="image-20240503203542689"></p>
<h4 id="strsignal-函数-："><a href="#strsignal-函数-：" class="headerlink" title="strsignal()函数 ："></a>strsignal()函数 ：</h4><p>用来获取信号的描述字符串，推荐使用这种方案。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strsignal</span><span class="params">(<span class="type">int</span> sig)</span>;  </span><br></pre></td></tr></table></figure>

<p><strong>返回值：</strong>sig信号描述信息字符串的指针 。函数会对参数 sig 进行检查，若传入的 sig 无效，则会返回”Unknown signal”信息  。</p>
<p><strong>sig</strong>：指定信号</p>
<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 描述信息: %s\n&quot;</span>, strsignal(SIGINT));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 描述信息: %s\n&quot;</span>, strsignal(SIGQUIT));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGBUS 描述信息: %s\n&quot;</span>, strsignal(SIGBUS));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;编号为 1000 的描述信息: %s\n&quot;</span>, strsignal(<span class="number">1000</span>));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ten@ten-virtual-machine:~/H616/demo$ ./sig</span><br><span class="line">SIGINT 描述信息: Interrupt</span><br><span class="line">SIGQUIT 描述信息: Quit</span><br><span class="line">SIGBUS 描述信息: Bus error</span><br><span class="line">编号为 1000 的描述信息: Unknown signal 1000</span><br></pre></td></tr></table></figure>

<h4 id="psignal-函数"><a href="#psignal-函数" class="headerlink" title="psignal()函数"></a>psignal()函数</h4><p>可以在标准错误（stderr）上输出信号描述信息  </p>
<p><code>补充</code>：stderr不存在缓冲区，也就是说stderr的输出内容<strong>会直接打印在屏幕上</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">psignal</span><span class="params">(<span class="type">int</span> sig, <span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>sig</strong>：指定信号</p>
<p><strong>s：</strong>调用者需要添加的一些输出信息  </p>
<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    psignal(SIGINT, <span class="string">&quot;SIGINT 信号描述信息&quot;</span>);</span><br><span class="line">    psignal(SIGQUIT, <span class="string">&quot;SIGQUIT 信号描述信息&quot;</span>);</span><br><span class="line">    psignal(SIGBUS, <span class="string">&quot;SIGBUS 信号描述信息&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ten@ten-virtual-machine:~/H616/demo$ ./sig</span><br><span class="line">SIGINT 信号描述信息: Interrupt</span><br><span class="line">SIGQUIT 信号描述信息: Quit</span><br><span class="line">SIGBUS 信号描述信息: Bus error</span><br></pre></td></tr></table></figure>

<h3 id="信号掩码"><a href="#信号掩码" class="headerlink" title="信号掩码"></a>信号掩码</h3><p>内核为每一个进程维护了一个信号掩码（其实就是一个信号集） ，即一组信号。当进程接收到一个属于<br>信号掩码中定义的信号时，内核会将该信号进行阻塞、导致无法传递给进程进行处理，直到该信号从信号掩码中移除，内核才会把该信号传递给进程从而得到处理  。<code>注</code>:只是将该信号阻塞，并不是删除该信号了(可以理解为把信号堵在管道里了，当从信号掩码中移除信号时，该信号又就能出来了)。</p>
<p>向信号掩码中添加一个信号，通常有如下几种方式：</p>
<ul>
<li>当应用程序调用 signal()或 sigaction()函数为某一个信号设置处理方式时，进程会自动将该信号添加<br>到信号掩码中， 这样保证了在处理一个给定的信号时，如果此信号再次发生，那么它将会被阻塞；<br>当然对于 sigaction()而言，是否会如此，需要根据 sigaction()函数是否设置了 SA_NODEFER 标志<br>而定；当信号处理函数结束返回后，会自动将该信号从信号掩码中移除。  </li>
<li>使用 sigaction()函数为信号设置处理方式时，可以额外指定一组信号，当调用信号处理函数时将该<br>组信号自动添加到信号掩码中， 当信号处理函数结束返回后，再将这组信号从信号掩码中移除； 通<br>过 sa_mask 参数进行设置。</li>
<li>除了以上两种方式之外，还可以使用 sigprocmask()系统调用，随时可以显式地向信号掩码中添加&#x2F;<br>移除信号。</li>
</ul>
<p>**sigprocmask()**：向信号掩码中添加&#x2F;移除信号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>返回值：</strong>返回值： 成功返回 0；失败将返回-1，并设置 errno  。</p>
<p><strong>参数介绍：</strong></p>
<ul>
<li>how： 指定了调用函数时的一些行为。  <ul>
<li>SIG_BLOCK：将参数 set 所指向的信号集内的所有信号添加到进程的信号掩码中。换言之，将信<br>号掩码设置为当前值与 set 的并集。  </li>
<li>SIG_UNBLOCK：将参数 set 指向的信号集内的所有信号从进程信号掩码中移除</li>
<li>SIG_SETMASK：进程信号掩码直接设置为参数 set 指向的信号集</li>
</ul>
</li>
<li>set：指向的信号集内的所有信号添加到信号掩码中或者从信号掩码中移除；如果参数 set 为<br>NULL，则表示无需对当前信号掩码作出改动。  </li>
<li>oldset： 如果参数 oldset 不为 NULL，在向信号掩码中添加新的信号之前，获取到进程当前的信号掩码，存放在 oldset 所指定的信号集中；如果为 NULL 则表示不获取当前的信号掩码。</li>
</ul>
<p><strong>示例：</strong>由于将SIGINT信号加入了信号掩码，不会立马执行信号处理函数打印”执行信号处理函数…“，而是睡眠2秒后在””休眠结束“后打印”执行信号处理函数…“</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;执行信号处理函数...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">sigset_t</span> sig_set;</span><br><span class="line">    <span class="comment">/* 注册信号处理函数 */</span></span><br><span class="line">    sig.sa_handler = sig_handler;</span><br><span class="line">    sig.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == sigaction(SIGINT, &amp;sig, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 信号集初始化 */</span></span><br><span class="line">    sigemptyset(&amp;sig_set);</span><br><span class="line">    sigaddset(&amp;sig_set, SIGINT);</span><br><span class="line">    <span class="comment">/* 向信号掩码中添加信号 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == sigprocmask(SIG_BLOCK, &amp;sig_set, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 向自己发送信号 */</span></span><br><span class="line">    raise(SIGINT);</span><br><span class="line">    <span class="comment">/* 休眠 2 秒 */</span></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;休眠结束\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 从信号掩码中移除添加的信号 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == sigprocmask(SIG_UNBLOCK, &amp;sig_set, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ten@ten-virtual-machine:~/H616/demo$ ./sig</span><br><span class="line">休眠结束</span><br><span class="line">执行信号处理函数...</span><br></pre></td></tr></table></figure>

<h3 id="阻塞等待信号sigsuspend"><a href="#阻塞等待信号sigsuspend" class="headerlink" title="阻塞等待信号sigsuspend()"></a>阻塞等待信号sigsuspend()</h3><p>将恢复信号掩码和 pause()挂起进程这两个动作封装成一个原子操作  。<code>补充</code>：原子操作就是两个操作是在一起执行的，不会被打断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *mask)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值： sigsuspend()始终返回-1，并设置 errno 来指示错误（通常为 EINTR） ，表示被信号所中断，如<br>果调用失败，将 errno 设置为 EFAULT。  </p>
<p>mask： 参数 mask 指向一个信号集。  </p>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;执行信号处理函数...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">sigset_t</span> new_mask, old_mask, wait_mask;</span><br><span class="line">    <span class="comment">/* 信号集初始化 */</span></span><br><span class="line">    sigemptyset(&amp;new_mask);</span><br><span class="line">    sigaddset(&amp;new_mask, SIGINT);</span><br><span class="line">    sigemptyset(&amp;wait_mask);</span><br><span class="line">    <span class="comment">/* 注册信号处理函数 */</span></span><br><span class="line">    sig.sa_handler = sig_handler;</span><br><span class="line">    sig.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == sigaction(SIGINT, &amp;sig, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">    	 <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/* 向信号掩码中添加信号 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == sigprocmask(SIG_BLOCK, &amp;new_mask, &amp;old_mask))</span><br><span class="line">    &#123;</span><br><span class="line">     	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/* 执行保护代码段 */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;执行保护代码段&quot;</span>);</span><br><span class="line">    <span class="comment">/******************/</span></span><br><span class="line">    <span class="comment">/* 挂起、等待信号唤醒 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> != sigsuspend(&amp;wait_mask))		<span class="comment">//信号掩码被替wait_mask替换，wait_mask为空</span></span><br><span class="line">    &#123;</span><br><span class="line">    	 <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/* 恢复信号掩码 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == sigprocmask(SIG_SETMASK, &amp;old_mask, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们希望执行受保护代码段时不被 SIGINT 中断信号打断，所以在执行保护代码段之前<br>将 SIGINT 信号添加到进程的信号掩码中，执行完受保护的代码段之后，调用 sigsuspend()挂起进程，等待<br>被信号唤醒，被唤醒之后再解除 SIGINT 信号的阻塞状态。  </p>
<h3 id="实时性信号"><a href="#实时性信号" class="headerlink" title="实时性信号"></a>实时性信号</h3><p>Linux 内核定义了 31 个不同的实时信号，信号编号范围为 34~64，使用 SIGRTMIN 表示编号最小的实<br>时信号，使用 SIGRTMAX 表示编号最大的实时信号，其它信号编号可使用这两个宏加上一个整数或减去一<br>个整数。  </p>
<h4 id="sigpending-函数"><a href="#sigpending-函数" class="headerlink" title="sigpending()函数"></a>sigpending()函数</h4><p>当接收到的信号是在信号掩码中时，会被阻塞，此时信号被添加到进程的等待信号集（等待被处理，处于等待状态的信号）中  。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值： 成功返回 0；失败将返回-1，并设置 errno。  </p>
<p>set： 处于等待状态的信号会存放在参数 set 所指向的信号集中  。</p>
<p><strong>示例</strong></p>
<p><code>补充</code>：sigismember()此函数用于检查一个指定的信号是否在给定的信号集中,也就是检查该信号是否被阻塞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 定义信号集 */</span></span><br><span class="line">    <span class="type">sigset_t</span> sig_set;</span><br><span class="line">    <span class="comment">/* 将信号集初始化为空 */</span></span><br><span class="line">    sigemptyset(&amp;sig_set);</span><br><span class="line">    <span class="comment">/* 获取当前处于等待状态的信号 */</span></span><br><span class="line">    sigpending(&amp;sig_set);</span><br><span class="line">    <span class="comment">/* 判断 SIGINT 信号是否处于等待状态 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == sigismember(&amp;sig_set, SIGINT))</span><br><span class="line">    	<span class="built_in">puts</span>(<span class="string">&quot;SIGINT 信号处于等待状态&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!sigismember(&amp;sig_set, SIGINT))</span><br><span class="line">    	<span class="built_in">puts</span>(<span class="string">&quot;SIGINT 信号未处于等待状态&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="发送实时信号"><a href="#发送实时信号" class="headerlink" title="发送实时信号"></a>发送实时信号</h4><p>如果同一个信号在阻塞状态下产生了多次，那么会将该信号记录在等待信号集中，并在之后仅传递一次（仅当做发生了一次） ，这是标准信号的缺点之一。  </p>
<p>实时信号较之于标准信号，其优势如下  ：</p>
<ul>
<li>实时信号的信号范围有所扩大，可应用于应用程序自定义的目的，而标准信号仅提供了两个信号可<br>用于应用程序自定义使用： SIGUSR1 和 SIGUSR2  。</li>
<li>内核对于实时信号所采取的是队列化管理。如果将某一实时信号多次发送给另一个进程，那么将会<br>多次传递此信号。  </li>
<li>当发送一个实时信号时，可为信号指定伴随数据（一整形数据或者指针值），供接收信号的进程在<br>它的信号处理函数中获取。  </li>
<li>信号传递顺序得到保障。信号的编号越小，其优先级越高，如果是同一类型的多个信号在排队，那么信号（以及伴随数据）的传递顺序与信号发送来时的顺序保持一致。</li>
</ul>
<p>应用程序当中使用实时信号，需要有以下的两点要求：</p>
<ul>
<li><p>发送进程使用 sigqueue()系统调用发送信号及伴随数据</p>
</li>
<li><p>sa_handler接收进程使用sigaction函数为信号建立处理函数，并且使用sa_sigaction，而不是sa_handler。可以使用sa_handler，但是获取不到伴随数据了。</p>
<hr>
</li>
</ul>
<p><strong>sigqueue()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigqueue</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">union</span> sigval value)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值： 成功将返回 0；失败将返回-1，并设置 errno。  </p>
<p>参数介绍：</p>
<ul>
<li><p>pid： 指定接收信号的进程对应的 pid，将信号发送给该进程。  </p>
</li>
<li><p>sig： 指定需要发送的信号。与 kill()函数一样，也可将参数 sig 设置为 0，用于检查参数 pid 所指定的进<br>程是否存在。  </p>
</li>
<li><p>value： 参数 value 指定了信号的伴随数据， union sigval 数据类型。  union sigval 数据类型（共用体） 如下所示：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">sigval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> sival_int;</span><br><span class="line">    <span class="type">void</span> *sival_ptr;</span><br><span class="line">&#125; <span class="type">sigval_t</span>;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">					<span class="comment">/*发送进程使用 sigqueue()系统调用向另一个进程发送实时信号*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">sigval</span> <span class="title">sig_val</span>;</span></span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">int</span> sig;</span><br><span class="line">    <span class="comment">/* 判断传参个数 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">3</span> &gt; argc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 获取用户传递的参数 */</span></span><br><span class="line">    pid = atoi(argv[<span class="number">1</span>]);	<span class="comment">//接收进程pid</span></span><br><span class="line">    sig = atoi(argv[<span class="number">2</span>]);	<span class="comment">//发送的信号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid: %d\nsignal: %d\n&quot;</span>, pid, sig);</span><br><span class="line">    <span class="comment">/* 发送信号 */</span></span><br><span class="line">    sig_val.sival_int = <span class="number">10</span>; <span class="comment">//伴随数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == sigqueue(pid, sig, sig_val)) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;sigqueue error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;信号发送成功!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig, <span class="type">siginfo_t</span> *info, <span class="type">void</span> *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigval_t</span> sig_val = info-&gt;si_value;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收到实时信号: %d\n&quot;</span>, sig);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;伴随数据为: %d\n&quot;</span>, sig_val.sival_int);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="comment">/* 判断传参个数 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> &gt; argc)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">/* 获取用户传递的参数 */</span></span><br><span class="line">    num = atoi(argv[<span class="number">1</span>]);		<span class="comment">//接收的信号</span></span><br><span class="line">    <span class="comment">/* 为实时信号绑定处理函数 */</span></span><br><span class="line">    sig.sa_sigaction = sig_handler;</span><br><span class="line">    sig.sa_flags = SA_SIGINFO;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == sigaction(num, &amp;sig, <span class="literal">NULL</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 死循环 */</span></span><br><span class="line">    <span class="keyword">for</span> ( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">   		sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先运行接收进程，并且设置接收的信号为34。然后查看接收程序的pid，使用发送进程向该pid发送34信号</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ten@ten-virtual-machine:~/H616/demo$ ./testApp 34</span><br><span class="line">接收到实时信号: 34</span><br><span class="line">伴随数据为: 10</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ten@ten-virtual-machine:~/H616/demo$ ./testApp2 4218 34</span><br><span class="line">pid: 4218</span><br><span class="line">signal: 34</span><br><span class="line">信号发送成功!</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="异常退出-abort-函数"><a href="#异常退出-abort-函数" class="headerlink" title="异常退出 abort()函数"></a>异常退出 abort()函数</h3><p>进程异常退出使用 abort()终止进程运行，会生成核心转储文件，可用于判断程序调用 abort()时的程序状态  </p>
<p>当调用 abort()函数之后，内核会向进程发送 SIGABRT 信号，  SIGABRT 信号的系统默认操作是终止进程运行、并生成核心转储文件；  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;接收到信号: %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    sig.sa_handler = sig_handler;</span><br><span class="line">    sig.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == sigaction(SIGABRT, &amp;sig, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">abort</span>(); <span class="comment">// 调用 abort</span></span><br><span class="line">    <span class="keyword">for</span> ( ; ; )</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ten@ten-virtual-machine:~/H616/demo$ ./sig</span><br><span class="line">接收到信号: 6</span><br><span class="line">已中止 (核心已转储)</span><br></pre></td></tr></table></figure>

<p>从打印信息可知，即使在我们的程序当中捕获了 SIGABRT 信号，但是程序依然会无情的终止，无论阻<br>塞或忽略 SIGABRT 信号， abort()调用均不收到影响，总会成功终止进程  。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/04/29/XJZajStb.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/04/29/XJZajStb.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Ten</div><div class="post-copyright__author_desc">记得给自己磕头</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2024/04/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2024/04/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/')">进程间通信</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://img2.imgtp.com/2024/04/29/ZLUmR1ch.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/04/29/ZLUmR1ch.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://img2.imgtp.com/2024/04/29/jhBLTmH3.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/04/29/jhBLTmH3.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2024/04/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=进程间通信&amp;url=http://example.com/2024/04/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/&amp;pic=https://img2.imgtp.com/2024/04/30/9GnvXoDg.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Ten-zzZ</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/linux/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>linux<span class="tagsPageCount">8</span></a><a class="post-meta__box__tags" href="/tags/%E9%80%9A%E4%BF%A1/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>通信<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://img2.imgtp.com/2024/05/13/IAYeaBKD.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/30/%E8%BF%9B%E7%A8%8B/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/04/30/ZamtkUJE.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">进程</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/02/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/05/02/sMAf8Hrd.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">踩坑记录</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2024/05/04/Linux%E7%BA%BF%E7%A8%8B/" title="Linux线程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/05/05/Bg6p4Ceu.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-05-04</div><div class="title">Linux线程</div></div></a></div><div><a href="/2024/05/02/Makefile/" title="Makefile"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/05/02/96JZQtZT.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-05-02</div><div class="title">Makefile</div></div></a></div><div><a href="/2024/04/29/Socket%E7%BC%96%E7%A8%8B/" title="Socket编程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/04/29/aStIRPSU.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-04-29</div><div class="title">Socket编程</div></div></a></div><div><a href="/2024/05/03/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%84%E5%BB%BA/" title="嵌入式Linux系统的构建"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/05/03/yIu4n2xM.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-05-03</div><div class="title">嵌入式Linux系统的构建</div></div></a></div><div><a href="/2024/05/02/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E9%85%8D%E7%BD%AE/" title="交叉编译工具链配置"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/05/02/1T6KlZGz.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-05-02</div><div class="title">交叉编译工具链配置</div></div></a></div><div><a href="/2024/05/03/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/" title="线程同步"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="//img2.imgtp.com/2024/05/05/5xd3Cvv5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-05-03</div><div class="title">线程同步</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/04/29/XJZajStb.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">欢迎来到我的嵌入式学习笔记！这里是我作为一个初学者的探索记录，我们一起从零开始，一步步解开嵌入式的神秘面纱。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Ten</h1><div class="author-info__desc">记得给自己磕头</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/Ten-zzZ" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/352659041" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">2.</span> <span class="toc-text">管道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">2.1.</span> <span class="toc-text">匿名管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">2.2.</span> <span class="toc-text">命名管道</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%88%96%E6%89%93%E5%BC%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A"><span class="toc-number">3.0.1.</span> <span class="toc-text">创建或打开消息队列：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%B6%88%E6%81%AF"><span class="toc-number">3.0.2.</span> <span class="toc-text">添加消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%B6%88%E6%81%AF"><span class="toc-number">3.0.3.</span> <span class="toc-text">读取消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">3.0.4.</span> <span class="toc-text">消息队列的控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">4.</span> <span class="toc-text">共享内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%88%96%E8%8E%B7%E5%8F%96%E2%80%94%E2%80%94shmget"><span class="toc-number">4.0.1.</span> <span class="toc-text">创建或获取——shmget()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E2%80%94%E2%80%94shmat"><span class="toc-number">4.0.2.</span> <span class="toc-text">连接——shmat()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E2%80%94%E2%80%94shmdt"><span class="toc-number">4.0.3.</span> <span class="toc-text">分离——shmdt()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E2%80%94%E2%80%94shmctl"><span class="toc-number">4.0.4.</span> <span class="toc-text">控制——shmctl()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">5.</span> <span class="toc-text">信号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">信号的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%AF%B9%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">进程对信号的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#signal-%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.1.</span> <span class="toc-text">signal()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sigaction-%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.2.</span> <span class="toc-text">sigaction()函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E8%BF%9B%E7%A8%8B%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-number">5.3.</span> <span class="toc-text">向进程发送信号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kill-%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.1.</span> <span class="toc-text">kill()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#raise-%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.2.</span> <span class="toc-text">raise()函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#alarm-%E5%92%8C-pause-%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">alarm()和 pause()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#alarm-%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.1.</span> <span class="toc-text">alarm()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pause-%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.2.</span> <span class="toc-text">pause()函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="toc-number">5.5.</span> <span class="toc-text">信号集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="toc-number">5.5.1.</span> <span class="toc-text">初始化信号集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E4%BF%A1%E5%8F%B7%E9%9B%86%E4%B8%AD%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4%E4%BF%A1%E5%8F%B7"><span class="toc-number">5.5.2.</span> <span class="toc-text">向信号集中添加&#x2F;删除信号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E4%BF%A1%E5%8F%B7%E6%98%AF%E5%90%A6%E5%9C%A8%E4%BF%A1%E5%8F%B7%E9%9B%86%E4%B8%AD"><span class="toc-number">5.6.</span> <span class="toc-text">测试信号是否在信号集中</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%BF%A1%E5%8F%B7%E6%8F%8F%E8%BF%B0%E4%BF%A1%E6%81%AF"><span class="toc-number">5.6.1.</span> <span class="toc-text">获取信号描述信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strsignal-%E5%87%BD%E6%95%B0-%EF%BC%9A"><span class="toc-number">5.6.2.</span> <span class="toc-text">strsignal()函数 ：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#psignal-%E5%87%BD%E6%95%B0"><span class="toc-number">5.6.3.</span> <span class="toc-text">psignal()函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%8E%A9%E7%A0%81"><span class="toc-number">5.7.</span> <span class="toc-text">信号掩码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E7%AD%89%E5%BE%85%E4%BF%A1%E5%8F%B7sigsuspend"><span class="toc-number">5.8.</span> <span class="toc-text">阻塞等待信号sigsuspend()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%80%A7%E4%BF%A1%E5%8F%B7"><span class="toc-number">5.9.</span> <span class="toc-text">实时性信号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sigpending-%E5%87%BD%E6%95%B0"><span class="toc-number">5.9.1.</span> <span class="toc-text">sigpending()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E5%AE%9E%E6%97%B6%E4%BF%A1%E5%8F%B7"><span class="toc-number">5.9.2.</span> <span class="toc-text">发送实时信号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E9%80%80%E5%87%BA-abort-%E5%87%BD%E6%95%B0"><span class="toc-number">5.10.</span> <span class="toc-text">异常退出 abort()函数</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/05/13/FreeRTOS/" title="FreeRTOS"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/05/13/IAYeaBKD.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="FreeRTOS"/></a><div class="content"><a class="title" href="/2024/05/13/FreeRTOS/" title="FreeRTOS">FreeRTOS</a><time datetime="2024-05-13T08:06:10.000Z" title="发表于 2024-05-13 16:06:10">2024-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/13/ADC%E5%92%8CDMA/" title="ADC和DMA"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/05/13/dLVYfxUA.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ADC和DMA"/></a><div class="content"><a class="title" href="/2024/05/13/ADC%E5%92%8CDMA/" title="ADC和DMA">ADC和DMA</a><time datetime="2024-05-13T02:02:48.000Z" title="发表于 2024-05-13 10:02:48">2024-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/12/STM32/" title="STM32 HAL库版本"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/05/12/YamYeyQj.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="STM32 HAL库版本"/></a><div class="content"><a class="title" href="/2024/05/12/STM32/" title="STM32 HAL库版本">STM32 HAL库版本</a><time datetime="2024-05-12T08:57:38.000Z" title="发表于 2024-05-12 16:57:38">2024-05-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/04/Linux%E7%BA%BF%E7%A8%8B/" title="Linux线程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/05/05/Bg6p4Ceu.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux线程"/></a><div class="content"><a class="title" href="/2024/05/04/Linux%E7%BA%BF%E7%A8%8B/" title="Linux线程">Linux线程</a><time datetime="2024-05-04T08:35:39.000Z" title="发表于 2024-05-04 16:35:39">2024-05-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/04/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%A8%A1%E6%9D%BF/" title="简单工厂模式"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/05/08/MIkSgHhh.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="简单工厂模式"/></a><div class="content"><a class="title" href="/2024/05/04/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%A8%A1%E6%9D%BF/" title="简单工厂模式">简单工厂模式</a><time datetime="2024-05-04T08:35:39.000Z" title="发表于 2024-05-04 16:35:39">2024-05-04</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="Ten" target="_blank">Ten</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">5</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/"><span> 音乐馆</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/FreeRTOS/" style="font-size: 0.88rem;">FreeRTOS<sup>1</sup></a><a href="/tags/STM32/" style="font-size: 0.88rem;">STM32<sup>2</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>8</sup></a><a href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 0.88rem;">单片机<sup>2</sup></a><a href="/tags/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/" style="font-size: 0.88rem;">实战项目<sup>1</sup></a><a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" style="font-size: 0.88rem;">嵌入式<sup>3</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">线程<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 0.88rem;">网络编程<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>1</sup></a><a href="/tags/%E8%BF%9B%E7%A8%8B/" style="font-size: 0.88rem;">进程<sup>2</sup></a><a href="/tags/%E9%80%9A%E4%BF%A1/" style="font-size: 0.88rem;">通信<sup>1</sup></a><a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 0.88rem;">随笔<sup>2</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'default' : 'light'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>
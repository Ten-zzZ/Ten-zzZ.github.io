<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>FreeRTOS | Ten-zzZ</title><meta name="keywords" content="FreeRTOS"><meta name="author" content="Ten"><meta name="copyright" content="Ten"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="FreeRTOS"><meta name="application-name" content="FreeRTOS"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="FreeRTOS"><meta property="og:url" content="http://example.com/2024/05/13/FreeRTOS/index.html"><meta property="og:site_name" content="Ten-zzZ"><meta property="og:description" content="初识FreeRTOS什么是FreeRTOSRTOS （实时操作系统）并不是指某一特定的操作系统，而是指一类操作系统，例如， µC&amp;#x2F;OS，FreeRTOS， RTX， RT-Thread 等这些都是 RTOS 类的操作系统。 因此，从 FreeRTOS 的名字中就能看出， FreeROTS"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://img2.imgtp.com/2024/05/13/IAYeaBKD.jpg"><meta property="article:author" content="Ten"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img2.imgtp.com/2024/05/13/IAYeaBKD.jpg"><meta name="description" content="初识FreeRTOS什么是FreeRTOSRTOS （实时操作系统）并不是指某一特定的操作系统，而是指一类操作系统，例如， µC&amp;#x2F;OS，FreeRTOS， RTX， RT-Thread 等这些都是 RTOS 类的操作系统。 因此，从 FreeRTOS 的名字中就能看出， FreeROTS"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2024/05/13/FreeRTOS/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: {"mode":"api","api":"https://github.com/anzhiyu-c/img2color-go","cover_change":true},
  authorStatus: {"skills":["🌐 浏览器里的探险家"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Ten","link":"链接: ","source":"来源: Ten-zzZ","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Ten-zzZ',
  title: 'FreeRTOS',
  postAI: '',
  pageFillDescription: '初识FreeRTOS, 什么是FreeRTOS, 为什么选择FreeRTOS, FreeRTOS的特点, FreeRTOS移植, 使用CubeMX快速移植, FreeRTOS系统配置, FreeRTOSConfig.h 文件, 任务的创建与删除, 什么是任务？, 任务创建与删除相关函数, 创建两个任务进行点灯实操, 任务调度, 什么是任务调度？, FreeRTOS的任务调度规则是怎样的？, 抢占式调度运行过程, 时间片调度运行过程, 任务状态, 任务调度和任务的状态案例分析, 队列, 什么是队列？, 消息队列相关 API 函数, 创建队列, 写队列, 读队列, 消息队列实操, 二值信号量, 什么是信号量？, 什么是二值信号量？, 二值信号量相关 API 函数, 创建二值信号量, 释放二值信号量, 获取二值信号量, 二值信号量实操, 计数型信号量, 什么是计数型信号量？, 计数型信号量相关 API 函数, 创建计数型信号量, 释放计数型信号量, 获取计数型信号量, 计数型信号量实操, 互斥量, 什么是互斥量？, 什么是优先级反转（翻转）和优先级继承, 互斥量相关 API 函数, 优先级反转（翻转）示例, 使用互斥量优化优先级反转（翻转）问题示例, 事件标志组, 什么是事件标志组？, 事件标志组相关 API 函数, 创建事件标志组, 设置事件标志位, 清除事件标志位, 等待事件标志位, 事件标志组实操, 任务通知, 什么是任务通知？, 发送通知给任务 ：, 任务通知的优势和劣势, 任务通知相关 API 函数, 发送通知, 等待通知, 任务通知实操, 模拟二值信号量, 模拟计数型信号量, 模拟事件标志组, 模拟消息邮箱, 延时函数和软件定时器, 什么是延时函数？, 延时函数分类, 什么是定时器？, 软件定时器相关 API 函数, 创建软件定时器, 开启软件定时器, 停止软件定时器, 复位软件定时器, 更改软件定时器定时时间, 延时函数和软件定时器实操, 中断管理, 中断定义, 中断优先级, 中断相关函数, 队列, 信号量, 事件标志组, 任务通知, 软件定时器, 中断管理实操初识什么是实时操作系统并不是指某一特定的操作系统而是指一类操作系统例如等这些都是类的操作系统因此从的名字中就能看出是一款免费的实时操作系统操作系统是允许多个任务同时运行的然而实际上一个核心在某一时刻只能运行一个任务而操作系统中任务调度器的责任就是决定在某一时刻究竟要运行哪一个任务任务调度器使得在各个任务之间来回切换并处理任务由于切换处理任务的速度非常快因此就给人造成了一种同一时刻有多个任务同时运行的错觉是众多类操作系统中的一种十分的小巧可以在资源有限的微控制器中运行当然了也不仅仅局限于在微控制器中使用就单从文件数量上来看要比少得多为什么选择免费简单使用广泛资料齐全可移植性强的特点移植使用快速移植在选项里将设为并且将设为其它定时器也行为何要如此配置下文解说将里的设置为时钟按下图配置选择选项并将改为和有啥区别下文解释配置项目信息并导出代码一些常见问题为什么不能设置为裸机的时钟源默认是但是开启后会占用用来生成定时用于任务调度所以需要为其他总线提供另外的时钟源版本问题的内核版本更高功能更多在大多数情况下版本的内核完全够用各配置选项卡的解释事件相关的创建任务与队列的创建定时器和信号量的创建互斥量的创建用于查看堆使用情况内核参数设置用户根据自己的实际应用来裁剪定制内核部分函数的使能相关宏的定义可以自建一些常量在工程中使用高级设置系统配置文件使用文件进行配置和裁剪文件中有几十个配置项这使得用户能够很好地配置和裁剪文件中的配置项可分为三大类配置项配置项和其他配置项头文件基础配置项抢占式调度器协程式调度器无默认需定义使用硬件计算下一个要运行的任务使用软件算法计算下一个要运行的任务默认使能低功耗模式默认定义主频单位无默认需定义定义时钟频率当时钟频率与内核时钟频率不同时才可以定义单位默认不定义定义系统时钟节拍频率单位无默认需定义定义最大优先级数最大优先级无默认需定义定义空闲任务的栈空间大小单位无默认需定义定义任务名最大字符数默认定义系统时钟节拍计数器的数据类型为位无符号数无默认需定义使能在抢占式调度下同优先级的任务能抢占空闲任务默认使能任务间直接的消息传递包括信号量事件标志组和消息邮箱默认定义任务通知数组的大小默认使能互斥信号量默认使能递归互斥信号量默认使能计数信号量默认已弃用定义可以注册的信号量和消息队列的个数默认使能队列集默认使能时间片调度默认任务创建时分配的重入结构体默认使能兼容老版本默认定义线程本地存储指针的个数默认定义任务堆栈深度的数据类型默认定义消息缓冲区中消息长度的数据类型默认内存分配相关定义支持静态申请内存默认支持动态申请内存默认堆中可用的总量单位无默认需定义用户手动分配内存堆默认用户自行实现任务创建时使用的内存申请与释放函数默认钩子函数相关定义使能空闲任务钩子函数无默认需定义使能系统时钟节拍中断钩子函数无默认需定义使能栈溢出检测方法使能栈溢出检测方法默认使能动态内存申请失败钩子函数默认使能定时器服务任务首次执行前的钩子函数默认运行时间和任务状态统计相关定义使能任务运行时间统计功能默认使能可视化跟踪调试默认为时会编译和函数默认协程相关定义启用协程默认定义协程的最大优先级最大优先级无默认为时需定义软件定时器相关定义使能软件定时器默认定义软件定时器任务的优先级无默认为时需定义定义软件定时器命令队列的长度无默认为时需定义定义软件定时器任务的栈空间大小无默认为时需定义可选函数使能设置任务优先级获取任务优先级删除任务挂起任务恢复在中断中挂起的任务任务绝对延时任务延时获取任务调度器状态获取当前任务的任务句柄获取任务堆栈历史剩余最小值获取空闲任务的任务句柄获取任务状态在中断中设置事件标志位将函数的执行挂到定时器服务任务中断任务延时通过任务名获取任务句柄恢复在中断中挂起的任务中断嵌套行为配置中断最低优先级可管理的最高中断优先级中断服务函数相关定义断言特殊定义安全侧端口相关定义任务的创建与删除什么是任务任务可以理解为进程线程创建一个任务就会在内存开辟一个空间任务可以被认为是一组函数它们在运行时相互协作以完成特定的目标在中任务可以分配不同的优先级并按照优先级进行调度当一个任务没有工作可以做时操作系统会将时间分配给另一个优先级更高的任务以确保系统的正常运行任务通常都含有死循环任务创建与删除相关函数任务创建与删除相关函数有如下三个函数名称函数作用动态方式创建任务静态方式创建任务删除任务任务动态创建与静态创建的区别动态创建任务的堆栈由系统分配而静态创建任务的堆栈由用户自己传递通常情况下使用动态方式创建任务函数原型指向任务函数的指针任务必须实现为永不返回即连续循环任务的名字主要是用来调试默认情况下最大长度是指定的任务栈的大小任务优先级数值越大优先级越大用于返回已创建任务的句柄可以被引用返回值描述任务创建成功任务创建失败函数原型只需将待删除的任务句柄传入该函数即可将该任务删除当传入的参数为则代表删除任务自身当前正在运行的任务创建两个任务进行点灯实操增加两个任务一个用于点亮一个用于点亮查看原理图设置两个灯的引脚为输出引脚导出代码后加入下面代码编译烧录单片机文件任务函数任务函数任务调度什么是任务调度调度器就是使用相关的调度算法来决定当前需要执行的哪个任务中开启任务调度的函数是但在中被封装为的任务调度规则是怎样的高优先级抢占低优先级任务系统永远执行最高优先级的任务即抢占式调度同等优先级的任务轮转调度即时间片调度携程式调度但官方已明确表示不更新主要是用在小容量的芯片上用得也不多抢占式调度运行过程前提任务优先级不同总结高优先级任务优先执行高优先级任务不停止低优先级任务无法执行被抢占的任务将会进入就绪态时间片调度运行过程前提任务优先级相同总结同等优先级任务轮流执行时间片流转一个时间片大小取决为滴答定时器中断周期默认注意没有用完的时间片不会再使用下次任务得到执行还是按照一个时间片的时钟节拍运行任务状态中任务共存在种状态运行态当任务处于实际运行状态称之为运行态即的使用权被这个任务占用同一时间仅一个任务处于运行态就绪态处于就绪态的任务是指那些能够运行没有被阻塞和挂起但是当前没有运行的任务因为同优先级或更高优先级的任务正在运行阻塞态如果一个任务因延时或等待信号量消息队列事件标志组等而处于的状态被称之为阻塞态挂起态类似暂停通过调用函数对指定任务进行挂起挂起后这个任务将不被执行只有调用函数才可以将这个任务从挂起态恢复任务调度和任务的状态案例分析实验需求创建个任务任务要求如下间隔闪烁间隔闪烁如果存在则按下后删除否则创建如果正常运行则按下后挂起否则恢复延时消抖被按下任务不存在准备创建任务任务创建成功删除任务延时消抖被按下任务被挂起暂停任务重新恢复队列什么是队列队列又称消息队列是一种常用于任务间通信的数据结构队列可以在任务与任务间中断和任务间传递信息为什么不使用全局变量如果使用全局变量任务修改了变量等待任务处理但任务处理速度很慢在处理数据的过程中任务有可能又修改了变量导致任务有可能得到的不是正确的数据在这种情况下就可以使用队列任务和任务产生的数据放在流水线上任务可以慢慢一个个依次处理关于队列的几个名词创建队列时需要指定队列长度及队列项目大小队列项目队列中的每一个数据队列长度队列能够存储队列项目的最大数量消息队列特点数据入队出队方式通常采用先进先出的数据存储缓冲机制即先入队的数据会先从队列中被读取也可以配置为后进先出方式但用得比较少数据传递方式采用实际值传递即将数据拷贝到队列中进行传递也可以传递指针在传递较大的数据的时候采用指针传递多任务访问队列不属于某个任务任何任务和中断都可以向队列发送读取消息出队入队阻塞当任务向一个队列发送消息时可以指定一个阻塞时间假设此时当队列已满无法入队阻塞时间如果设置为直接返回不会等待等待设定的阻塞时间若在该时间内还无法入队超时后直接返回不再等待死等一直等到可以入队为止出队阻塞与入队阻塞类似消息队列相关函数创建队列参数队列可同时容纳的最大项目数存储队列中的每个数据项所需的大小以字节为单位返回值如果队列创建成功则返回所创建队列的句柄如果创建队列所需的内存无法分配则返回写队列函数描述往队列的尾部写入消息同往队列的头部写入消息覆写队列消息只用于队列长度为的情况在中断中往队列的尾部写入消息同在中断中往队列的头部写入消息在中断中覆写队列消息只用于队列长度为的情况参数队列的句柄数据项将发送到此队列待写入数据阻塞超时时间返回值如果成功写入数据返回否则返回读队列函数描述从队列头部读取消息并删除消息从队列头部读取消息但是不删除消息在中断中从队列头部读取消息并删除消息在中断中从队列头部读取消息参数待读取的队列数据读取缓冲区阻塞超时时间返回值成功返回否则返回消息队列实操要求创建一个队列按下向队列发送数据按下向队列读取数据然后创建两个任务和一个队列设置按键引脚为输入然后导出代码用于监听按下向队列发送消息消抖写入队列成功写入队列失败检测一次用于监听按下从队列中读出消息消抖读出队列成功读出队列失败二值信号量什么是信号量信号量是在多任务环境下使用的一种机制是可以用来保证两个或多个关键代码段不被并发调用信号量这个名字我们可以把它拆分来看信号可以起到通知信号的作用然后我们的量还可以用来表示资源的数量当我们的量只有和的时候它就可以被称作二值信号量只有两个状态当我们的那个量没有限制的时候它就可以被称作为计数型信号量信号量也是队列的一种什么是二值信号量二值信号量其实就是一个长度为大小为零的队列只有和两种状态通常情况下我们用它来进行互斥访问或任务同步互斥访问比如门跟钥匙只有获取到钥匙才可以开门任务同步比如录完视频后才能看视频二值信号量相关函数函数描述使用动态方式创建二值信号量使用静态方式创建二值信号量释放信号量在中断中释放信号量获取信号量在中断中获取信号量创建二值信号量参数无返回值成功返回对应二值信号量的句柄失败返回注意创建信号量时默认会释放释放二值信号量参数要释放的信号量句柄返回值成功返回失败返回获取二值信号量参数要获取的信号量句柄超时时间表示不超时表示卡死等待返回值成功返回失败返回二值信号量实操实验需求创建一个二值信号量按下则释放信号量按下获取信号量打开创建两个任务用来放入和获取信号量进行代码编写检测按下释放信号量释放二值信号量成功释放二值信号量失败检测按下获取信号量获取二值信号量成功获取二值信号量失败串口调试创建信号时默认会释放一次计数型信号量什么是计数型信号量计数型信号量相当于队列长度大于的队列因此计数型信号量能够容纳多个资源这在计数型信号量被创建的时候确定的使用计数型信号量可以解决多个任务之间的同步问题例如控制对共享资源的访问和协调任务的执行顺序计数型信号量相关函数计数型信号量的释放和获取与二值信号量完全相同函数描述使用动态方法创建计数型信号量使用静态方法创建计数型信号量获取信号量的计数值创建计数型信号量参数可以达到的最大计数值创建信号量时分配给信号量的计数值返回值成功返回对应计数型信号量的句柄失败返回释放计数型信号量参数要释放的信号量句柄返回值成功返回失败返回获取计数型信号量参数要获取的信号量句柄超时时间表示不超时表示卡死等待返回值成功返回失败返回计数型信号量实操打开创建两个任务和设置按键引脚为输入通过按键来放入和获取信号量使能计数信号量创建一个计数信号量设置最多存放个信号量进行代码编写监听按下释放计数型信号量释放计数型信号量成功释放计数型信号量失败监听按下获取计数型信号量获取计数型信号量成功获取计数型信号量失败串口调试互斥量什么是互斥量在多数情况下互斥型信号量和二值型信号量非常相似但是从功能上二值型信号量用于同步而互斥型信号量用于资源保护互斥型信号量和二值型信号量还有一个最大的区别互斥型信号量可以有效解决优先级反转现象什么是优先级反转翻转和优先级继承以上图为例系统中有个不同优先级的任务最高优先级任务和最低优先级任务通过信号量机制共享资源目前任务占有资源锁定了信号量运行后将被阻塞直到释放信号量后才能够退出阻塞状态继续运行但是在等待释放信号量的过程中中等优先级任务抢占了任务从而延迟了信号量的释放时间导致阻塞了更长时间这种现象称为优先级倒置或优先级反转翻转优先级继承当一个互斥信号量正在被一个低优先级的任务持有时如果此时有个高优先级的任务也尝试获取这个互斥信号量那么这个高优先级的任务就会被阻塞不过这个高优先级的任务会将低优先级任务的优先级提升到与自己相同的优先级优先级继承并不能完全的消除优先级翻转的问题它只是尽可能的降低优先级翻转带来的影响互斥量相关函数互斥信号量不能用于中断服务函数中函数描述使用动态方法创建互斥信号量使用静态方法创建互斥信号量参数无返回值成功返回对应互斥量的句柄失败返回优先级反转翻转示例如下图低优先级工作后高优先级被阻塞然后发生优先级反转中优先级比高优先级先工作打开增加三个任务优先级分别从高到低增加一个二值信号量代码编写获取二值信号量高优先级获得二值信号量开始工作工作完毕后释放二值信号量释放二值信号量占用资源我就是玩获取二值信号量低优先级获得二值信号量开始工作工作完毕后释放二值信号量释放二值信号量串口调试使用互斥量优化优先级反转翻转问题示例使用在优先级反转示例中增加互斥量导出代码编写代码获取二值信号量高优先级获得二值信号量开始工作工作完毕后释放二值信号量释放二值信号量占用资源我就是玩获取二值信号量低优先级获得二值信号量开始工作工作完毕后释放二值信号量释放二值信号量串口调试事件标志组什么是事件标志组事件标志位表明某个事件是否发生联想全局变量通常按位表示每一个位表示一个事件高位不算事件标志组是一组事件标志位的集合可以简单的理解事件标志组就是一个整数事件标志组本质是一个位或位无符号的数据类型由决定虽然使用了位无符号的数据类型变量来存储事件标志但其中的高位用作存储事件标志组的控制信息低位用作存储事件标志所以说一个事件组最多可以存储个事件标志事件标志组相关函数函数描述使用动态方式创建事件标志组使用静态方式创建事件标志组清零事件标志位在中断中清零事件标志位设置事件标志位在中断中设置事件标志位等待事件标志位创建事件标志组参数无返回值成功返回对应事件标志组的句柄失败返回设置事件标志位参数对应事件组句柄指定要在事件组中设置的一个或多个位的按位值返回值设置之后事件组中的事件标志位值清除事件标志位参数对应事件组句柄指定要在事件组中清除的一个或多个位的按位值返回值清零之前事件组中事件标志位的值等待事件标志位参数对应的事件标志组句柄指定事件组中要等待的一个或多个事件位的按位值清除对应事件位不清除所有等待事件位全为逻辑与等待的事件位有一个为逻辑或超时时间表示不超时表示卡死等待返回值等待的事件标志位值等待事件标志位成功返回等待到的事件标志位其他值等待事件标志位失败返回事件组中的事件标志位事件标志组实操创建一个事件标志组和两个任务和检测按键如果检测到和都按过则执行打开增加两个任务配置两个输入引脚给按键和在代码中创建一个事件标志组定义事件标志组句柄创建事件标志组检测按键如果检测到和都按过则执行检测和有没有按下如果按下则设置相应的事件标志组位检测有无被按下按下后设置事件标志组最低位按键按下检测有无被按下按下后设置事件标志组第二低位按键按下该任务用于等待事件标志组返回值按键都按下任务执行了是带格式输出效果为在输出前加打开串口助手看运行结果任务通知什么是任务通知从版本开始提供任务通知这个功能每个任务都有一个位的通知值按照官方的说法使用消息通知比通过二进制信号量方式解除阻塞任务快并且更加省内存无需创建队列在大多数情况下任务通知可以替代二值信号量计数信号量事件标志组可以替代长度为的队列可以保存一个位整数或指针值并且任务通知速度更快使用的更少任务一给任务二发送通知其实就是任务一操作任务二的里面的给它写入相应的值任务都有一个结构体任务控制块它里边有两个结构体成员变量定义任务通知数组的大小默认一个是类型用来表示通知值一个是类型用来表示通知状态发送通知给任务通过对以下方式的合理使用可以在一定场合下替代原本的队列信号量事件标志组等发送消息给任务如果有通知未读不覆盖通知值发送消息给任务直接覆盖通知值发送消息给任务设置通知值的一个或者多个位发送消息给任务递增通知值任务通知的优势和劣势任务通知的优势使用任务通知向任务发送事件或数据比使用队列事件标志组或信号量快得多使用其他方法时都要先创建对应的结构体使用任务通知时无需额外创建结构体任务通知的劣势只有任务可以等待通知中断服务函数中不可以因为中断没有通知只能一对一因为通知必须指定任务等待通知的任务可以被阻塞但是发送消息的任务任何情况下都不会被阻塞等待任务通知是通过更新任务通知值来发送数据的任务结构体中只有一个任务通知值只能保持一个数据任务通知相关函数发送通知函数描述发送通知带有通知值发送通知带有通知值并且保留接收任务的原通知值发送通知不带通知值在中断中发送任务通知在中断中发送任务通知在中断中发送任务通知参数需要接收通知的任务句柄用于更新接收任务通知值具体如何更新由形参决定一个枚举代表如何使用任务通知的值枚举值描述发送通知但不更新值参数未使用被通知任务的通知值按位或某些场景下可代替事件组效率更高被通知任务的通知值增加参数未使用相当于被通知任务的通知值设置为某些场景下可代替效率更高如果被通知的任务当前没有通知则被通知的任务的通知值设为如果被通知任务没有取走上一个通知又接收到了一个通知则这次通知值丢弃在这种情况下视为调用失败并返回某些场景下可代替效率更高返回值如果被通知任务还没取走上一个通知又接收了一个通知则这次通知值未能更新并返回而其他情况均返回参数需要接收通知的任务句柄用于更新接收任务通知值具体如何更新由形参决定一个枚举代表如何使用任务通知的值对象任务的上一个任务通知值如果为则不需要回传这个时候就等价于函数返回值如果被通知任务还没取走上一个通知又接收了一个通知则这次通知值未能更新并返回而其他情况均返回参数接收通知的任务句柄并让其自身的任务通知值加返回值总是返回等待通知等待通知函数只能用在任务不可应用于中断中函数描述获取任务通知可以设置在退出此函数的时候将任务通知值清零或者减一当任务通知用作二值信号量或者计数信号量的时候使用此函数来获取信号量获取任务通知比更为复杂可获取通知值和清除通知值的指定位参数指定在成功接收通知后将通知值清零或减把通知值清零二值信号量把通知值减一计数型信号量阻塞等待任务通知值的最大时间超时时间表示不超时表示卡死等待返回值接收失败非接收成功返回任务通知的通知值参数函数执行前清零任务通知值那些位表示在函数退出前清零任务通知值那些位在清前接收到的任务通知值会先被保存到形参中用于保存接收到的任务通知值如果不需要使用则设置为即可等待消息通知的最大等待时间超时时间表示不超时表示卡死等待任务通知实操模拟二值信号量创建两个任务和设置按键引脚为输入设置两个按键分别发送和接收二值信号量用到函数发送任务通知模拟二值信号量释放接收任务通知模拟二值信号量接收打开串口助手查看结果模拟计数型信号量模拟计数型信号量跟模拟二值信号量基本相同将函数中第一个参数从改为代码示例用到函数发送任务通知模拟计数型信号量释放接收任务通知模拟二值技术型信号量接收模拟事件标志组用到函数示例代码将位置将位置任务通知模拟事件标志组接收成功模拟消息邮箱模拟邮箱大概就是向任务发送数据但是与队列不同任务邮箱发送消息受到了很多限制只能发送一个位的值消息邮箱的值被保存为一个任务的通知值而且只能保存一个任务的值相当于队列长度为用到函数示例代码按键按下按键按下接收到的通知值为延时函数和软件定时器什么是延时函数延时函数是一种编程语言中常用的函数类型用于暂停一段时间后再执行后续的操作在延时函数执行期间程序会暂停执行直到指定的时间结束后才会继续执行后续代码常见的延时函数参数是毫秒或微秒可以控制真实时间和计算机时间的关系延时函数常用于需要等待或暂停执行的场景如控制程序运行速度动画效果等不过过度使用延时函数可能会影响程序的性能和响应速度延时函数分类相对延时绝对延时与的区别作用是让任务阻塞任务阻塞后系统调用其它处于就绪状态的优先级最高的任务来执行一直不停的调用获取系统时间的函数直到指定的时间流逝然后退出故其占用了全部时间什么是定时器简单可以理解为闹钟到达指定一段时间后就会响铃芯片自带硬件定时器精度较高达到定时时间后会触发中断也可以生成输入捕获输出比较等等功能强大但是由于硬件的限制个数有限软件定时器也可以实现定时功能达到定时时间后可调用回调函数可以在回调函数里处理信息软件定时器优缺点优点简单成本低只要内存足够可创建多个缺点精度较低容易受中断影响在大多数情况下够用但对于精度要求比较高的场合不建议使用软件定时器原理定时器是一个可选的不属于内核的功能它是由定时器服务任务来提供的在调用函数开启任务调度器的时候会创建一个用于管理软件定时器的任务这个任务就叫做软件定时器服务任务负责软件定时器超时的逻辑判断调用超时软件定时器的超时回调函数处理软件定时器命令队列提供了很多定时器有关的函数这些函数大多都使用的队列发送命令给定时器服务任务这个队列叫做定时器命令队列定时器命令队列是提供给的软件定时器使用的用户不能直接访问软件定时器相关配置软件定时器有一个定时器服务任务和定时器命令队列这两个东西肯定是要配置的相关的配置也是放到文件中的涉及到的配置如下如果要使用软件定时器的话宏一定要设置为当设置为的话定时器服务任务就会在启动调度器的时候自动创建设置软件定时器服务任务的任务优先级可以为优先级一定要根据实际的应用要求来设置如果定时器服务任务的优先级设置的高的话定时器命令队列中的命令和定时器回调函数就会及时的得到处理此宏用来设置定时器命令队列的队列长度此宏用来设置定时器服务任务的任务堆栈大小单次定时器和周期定时器单次定时器只超时一次调用一次回调函数可手动再开启定时器周期定时器多次超时多次调用回调函数软件定时器相关函数函数描述动态方式创建软件定时器静态方式创建软件定时器开启软件定时器定时停止软件定时器定时复位软件定时器定时更改软件定时器的定时超时时间在中断中开启软件定时器定时在中断中停止软件定时器定时在中断中复位软件定时器定时在中断中更改定时超时时间创建软件定时器参数软件定时器名称定时超时时间单位系统时钟节拍宏可用于将以毫秒为单位指定的时间转换为以为单位指定的时间定时器模式周期定时器单次定时器软件定时器用于多个软件定时器公用一个超时回调函数软件定时器超时回调函数返回值成功定时器句柄失败开启软件定时器参数待开启的软件定时器的句柄发送命令到软件定时器命令队列的最大等待时间返回值开启成功开启失败停止软件定时器参数待开启的软件定时器的句柄发送命令到软件定时器命令队列的最大等待时间返回值开启成功开启失败复位软件定时器参数待开启的软件定时器的句柄发送命令到软件定时器命令队列的最大等待时间返回值开启成功开启失败该功能将使软件定时器的重新开启定时复位后的软件定时器以复位时的时刻作为开启时刻重新定时更改软件定时器定时时间新的定时超时时间单位系统时钟节拍其余参数与返回值同上延时函数和软件定时器实操创建两个定时器定时器周期定时器每秒打印一次定时器单次定时器启动后秒打印一次使能软件定时器创建两个定时器代码示例开启软件定时器定时时间为开启软件定时器定时时间为周期定时器单次定时器中断管理中断定义中断是指在程序执行的过程中突然发生了某种事件需要立即停止当前正在执行的程序并转而处理这个事件处理完后再回到原来的程序执行点继续执行的过程中断可以是硬件中断由硬件设备触发或软件中断由程序执行中断指令触发中断可以提高计算机的响应速度和效率使得计算机可以同时处理多个任务中断优先级任何中断的优先级都大于任务在我们的操作系统中断同样是具有优先级的并且我们也可以设置它的优先级但是他的优先级并不是从默认情况下它是从这个中断优先级不是控制的是取决于相关注意在中断中必需使用中断相关的函数中断服务函数运行时间越短越好中断相关函数队列在中断中从队列头部读取消息并删除消息在中断中从队列头部读取消息信号量在中断中释放信号量在中断中获取信号量事件标志组在中断中清零事件标志位在中断中设置事件标志位任务通知在中断中发送任务通知在中断中发送任务通知在中断中发送任务通知软件定时器在中断中开启软件定时器定时在中断中停止软件定时器定时在中断中复位软件定时器定时在中断中更改定时超时时间中断管理实操创建一个队列及一个任务按下按键触发中断在中断服务函数里向队列里发送数据任务则阻塞接收队列数据打开在中使能中断中断代码示例用到的中断函数增加封装好的头文件打开串口助手查看结果',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-16 16:03:23',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://img2.imgtp.com/2024/04/29/XJZajStb.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Ten-zzZ</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/"><span> 音乐馆</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://img2.imgtp.com/2024/04/29/ZLUmR1ch.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://img2.imgtp.com/2024/04/29/ZLUmR1ch.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://img2.imgtp.com/2024/04/29/jhBLTmH3.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://img2.imgtp.com/2024/04/29/jhBLTmH3.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/FreeRTOS/" style="font-size: 1.05rem;">FreeRTOS<sup>1</sup></a><a href="/tags/STM32/" style="font-size: 1.05rem;">STM32<sup>2</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>8</sup></a><a href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 1.05rem;">单片机<sup>2</sup></a><a href="/tags/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/" style="font-size: 1.05rem;">实战项目<sup>1</sup></a><a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" style="font-size: 1.05rem;">嵌入式<sup>3</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">线程<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 1.05rem;">网络编程<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>1</sup></a><a href="/tags/%E8%BF%9B%E7%A8%8B/" style="font-size: 1.05rem;">进程<sup>2</sup></a><a href="/tags/%E9%80%9A%E4%BF%A1/" style="font-size: 1.05rem;">通信<sup>1</sup></a><a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 1.05rem;">随笔<sup>2</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/FreeRTOS/" itemprop="url">FreeRTOS</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/FreeRTOS/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>FreeRTOS</span></a></span></div></div><h1 class="post-title" itemprop="name headline">FreeRTOS</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-05-13T08:06:10.000Z" title="发表于 2024-05-13 16:06:10">2024-05-13</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-05-16T08:03:23.039Z" title="更新于 2024-05-16 16:03:23">2024-05-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">12.8k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>45分钟</span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为新余"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>新余</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://img2.imgtp.com/2024/05/13/IAYeaBKD.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2024/05/13/FreeRTOS/"><header><a class="post-meta-categories" href="/categories/FreeRTOS/" itemprop="url">FreeRTOS</a><a href="/tags/FreeRTOS/" tabindex="-1" itemprop="url">FreeRTOS</a><h1 id="CrawlerTitle" itemprop="name headline">FreeRTOS</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Ten</span><time itemprop="dateCreated datePublished" datetime="2024-05-13T08:06:10.000Z" title="发表于 2024-05-13 16:06:10">2024-05-13</time><time itemprop="dateCreated datePublished" datetime="2024-05-16T08:03:23.039Z" title="更新于 2024-05-16 16:03:23">2024-05-16</time></header><h2 id="初识FreeRTOS"><a href="#初识FreeRTOS" class="headerlink" title="初识FreeRTOS"></a>初识FreeRTOS</h2><h3 id="什么是FreeRTOS"><a href="#什么是FreeRTOS" class="headerlink" title="什么是FreeRTOS"></a>什么是FreeRTOS</h3><p>RTOS （实时操作系统）并不是指某一特定的操作系统，而是指一类操作系统，例如， µC&#x2F;OS，FreeRTOS， RTX， RT-Thread 等这些都是 RTOS 类的操作系统。 因此，从 FreeRTOS 的名字中就能看出， FreeROTS 是一款免费的实时操作系统。  </p>
<p>操作系统是允许多个任务“同时运行” 的，  然而实际上， 一个 CPU 核心在某一时刻只能运行一个任务，而操作系统中任务调度器的责任就是决定在某一时刻 CPU 究竟要运行哪一个任务，任务调度器使得 CPU 在各个任务之间来回切换并处理任务， 由于切换处理任务的速度非常快，因此就给人造成了一种同一时刻有多个任务同时运行<br>的错觉。  </p>
<p>FreeRTOS 是众多 RTOS 类操作系统中的一种， FreeRTOS 十分的小巧，可以在资源有限的微控制器中运行，当然了， FreeRTOS 也不仅仅局限于在微控制器中使用。 就单从文件数量上来看 FreeRTOS 要比 µC&#x2F;OS 少得多。  </p>
<h3 id="为什么选择FreeRTOS"><a href="#为什么选择FreeRTOS" class="headerlink" title="为什么选择FreeRTOS"></a>为什么选择FreeRTOS</h3><ul>
<li>免费</li>
<li>简单</li>
<li>使用广泛</li>
<li>资料齐全</li>
<li>可移植性强</li>
</ul>
<h3 id="FreeRTOS的特点"><a href="#FreeRTOS的特点" class="headerlink" title="FreeRTOS的特点"></a>FreeRTOS的特点</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="../imgs/FreeRTOS/image-20240513163028964.png" alt="image-20240513163028964" style="zoom: 50%;" />

<h2 id="FreeRTOS移植"><a href="#FreeRTOS移植" class="headerlink" title="FreeRTOS移植"></a>FreeRTOS移植</h2><h3 id="使用CubeMX快速移植"><a href="#使用CubeMX快速移植" class="headerlink" title="使用CubeMX快速移植"></a>使用CubeMX快速移植</h3><ol>
<li>在 SYS 选项里，将 Debug 设为 Serial Wire ，并且将 Timebase Source 设为 TIM2 （其它定时器也行）。为何要如此配置？下文解说。</li>
</ol>
   <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="../imgs/FreeRTOS/image-20240514180203159.png" alt="image-20240514180203159" style="zoom:50%;" />

<ol start="2">
<li><p>将 RCC 里的 HSE 设置为 Crystal&#x2F;Ceramic Resonator   </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240514180257107.png" alt="image-20240514180257107"></p>
</li>
<li><p>时钟按下图配置  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240514180359669.png" alt="image-20240514180359669"></p>
</li>
<li><p>选择 FREERTOS 选项，并将 Interface 改为 CMSIS_V1 。V1 和 V2 有啥区别？下文解释。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240514180514717.png" alt="image-20240514180514717"></p>
</li>
<li><p>配置项目信息，并导出代码。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240514180919224.png" alt="image-20240514180919224"></p>
<p>一些常见问题</p>
<ol>
<li><p>Timebase Source 为什么不能设置为 SysTick ?裸机的时钟源默认是 SysTick，但是开启FreeRTOS 后，FreeRTOS会占用 SysTick （用来生成1ms 定时，用于任务调度），所以需要为其他总线提供另外的时钟源。</p>
</li>
<li><p>FreeRTOS 版本问题<br>V2 的内核版本更高，功能更多，在大多数情况下 V1 版本的内核完全够用。</p>
</li>
<li><p>FreeRTOS 各配置选项卡的解释</p>
</li>
<li><p>Events：事件相关的创建</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240514182104104.png" alt="image-20240514182104104"></p>
<p>Task and Queues： 任务与队列的创建<br>Timers and Semaphores： 定时器和信号量的创建<br>Mutexes： 互斥量的创建<br>FreeRTOS Heap Usage： 用于查看堆使用情况<br>config parameters： 内核参数设置，用户根据自己的实际应用来裁剪定制 FreeRTOS 内核 Include parameters： FreeRTOS 部分函数的使能<br>User Constants： 相关宏的定义，可以自建一些常量在工程中使用<br>Advanced settings：高级设置</p>
</li>
</ol>
</li>
</ol>
<h2 id="FreeRTOS系统配置"><a href="#FreeRTOS系统配置" class="headerlink" title="FreeRTOS系统配置"></a>FreeRTOS系统配置</h2><h3 id="FreeRTOSConfig-h-文件"><a href="#FreeRTOSConfig-h-文件" class="headerlink" title="FreeRTOSConfig.h 文件"></a>FreeRTOSConfig.h 文件</h3><p>FreeRTOS 使用 FreeRTOSConfig.h 文件进行配置和裁剪。 FreeRTOSConfig.h 文件中有几十个配置项，这使得用户能够很好地配置和裁剪 FreeRTOS。  </p>
<p>FreeRTOSConfig.h 文件中的配置项可分为三大类：“config”配置项、“INCLUDE”配置项和其他配置项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FREERTOS_CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FREERTOS_CONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 头文件 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./SYSTEM/sys/sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./SYSTEM/usart/usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> SystemCoreClock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基础配置项 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_PREEMPTION                            1                       <span class="comment">/* 1: 抢占式调度器, 0: 协程式调度器, 无默认需定义 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_PORT_OPTIMISED_TASK_SELECTION         1                       <span class="comment">/* 1: 使用硬件计算下一个要运行的任务, 0: 使用软件算法计算下一个要运行的任务, 默认: 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TICKLESS_IDLE                         0                       <span class="comment">/* 1: 使能tickless低功耗模式, 默认: 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configCPU_CLOCK_HZ                              SystemCoreClock         <span class="comment">/* 定义CPU主频, 单位: Hz, 无默认需定义 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configSYSTICK_CLOCK_HZ                          (configCPU_CLOCK_HZ / 8)<span class="comment">/* 定义SysTick时钟频率，当SysTick时钟频率与内核时钟频率不同时才可以定义, 单位: Hz, 默认: 不定义 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTICK_RATE_HZ                              1000                    <span class="comment">/* 定义系统时钟节拍频率, 单位: Hz, 无默认需定义 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_PRIORITIES                            32                      <span class="comment">/* 定义最大优先级数, 最大优先级=configMAX_PRIORITIES-1, 无默认需定义 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMINIMAL_STACK_SIZE                        128                     <span class="comment">/* 定义空闲任务的栈空间大小, 单位: Word, 无默认需定义 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_TASK_NAME_LEN                         16                      <span class="comment">/* 定义任务名最大字符数, 默认: 16 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_16_BIT_TICKS                          0                       <span class="comment">/* 1: 定义系统时钟节拍计数器的数据类型为16位无符号数, 无默认需定义 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configIDLE_SHOULD_YIELD                         1                       <span class="comment">/* 1: 使能在抢占式调度下,同优先级的任务能抢占空闲任务, 默认: 1 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TASK_NOTIFICATIONS                    1                       <span class="comment">/* 1: 使能任务间直接的消息传递,包括信号量、事件标志组和消息邮箱, 默认: 1 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTASK_NOTIFICATION_ARRAY_ENTRIES           1                       <span class="comment">/* 定义任务通知数组的大小, 默认: 1 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_MUTEXES                               1                       <span class="comment">/* 1: 使能互斥信号量, 默认: 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_RECURSIVE_MUTEXES                     1                       <span class="comment">/* 1: 使能递归互斥信号量, 默认: 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_COUNTING_SEMAPHORES                   1                       <span class="comment">/* 1: 使能计数信号量, 默认: 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_ALTERNATIVE_API                       0                       <span class="comment">/* 已弃用!!! */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configQUEUE_REGISTRY_SIZE                       8                       <span class="comment">/* 定义可以注册的信号量和消息队列的个数, 默认: 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_QUEUE_SETS                            1                       <span class="comment">/* 1: 使能队列集, 默认: 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TIME_SLICING                          1                       <span class="comment">/* 1: 使能时间片调度, 默认: 1 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_NEWLIB_REENTRANT                      0                       <span class="comment">/* 1: 任务创建时分配Newlib的重入结构体, 默认: 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configENABLE_BACKWARD_COMPATIBILITY             0                       <span class="comment">/* 1: 使能兼容老版本, 默认: 1 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configNUM_THREAD_LOCAL_STORAGE_POINTERS         0                       <span class="comment">/* 定义线程本地存储指针的个数, 默认: 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configSTACK_DEPTH_TYPE                          uint16_t                <span class="comment">/* 定义任务堆栈深度的数据类型, 默认: uint16_t */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMESSAGE_BUFFER_LENGTH_TYPE                size_t                  <span class="comment">/* 定义消息缓冲区中消息长度的数据类型, 默认: size_t */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内存分配相关定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configSUPPORT_STATIC_ALLOCATION                 0                       <span class="comment">/* 1: 支持静态申请内存, 默认: 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configSUPPORT_DYNAMIC_ALLOCATION                1                       <span class="comment">/* 1: 支持动态申请内存, 默认: 1 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTOTAL_HEAP_SIZE                           ((size_t)(10 * 1024))   <span class="comment">/* FreeRTOS堆中可用的RAM总量, 单位: Byte, 无默认需定义 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configAPPLICATION_ALLOCATED_HEAP                0                       <span class="comment">/* 1: 用户手动分配FreeRTOS内存堆(ucHeap), 默认: 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configSTACK_ALLOCATION_FROM_SEPARATE_HEAP       0                       <span class="comment">/* 1: 用户自行实现任务创建时使用的内存申请与释放函数, 默认: 0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 钩子函数相关定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_IDLE_HOOK                             0                       <span class="comment">/* 1: 使能空闲任务钩子函数, 无默认需定义  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TICK_HOOK                             0                       <span class="comment">/* 1: 使能系统时钟节拍中断钩子函数, 无默认需定义 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configCHECK_FOR_STACK_OVERFLOW                  0                       <span class="comment">/* 1: 使能栈溢出检测方法1, 2: 使能栈溢出检测方法2, 默认: 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_MALLOC_FAILED_HOOK                    0                       <span class="comment">/* 1: 使能动态内存申请失败钩子函数, 默认: 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_DAEMON_TASK_STARTUP_HOOK              0                       <span class="comment">/* 1: 使能定时器服务任务首次执行前的钩子函数, 默认: 0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运行时间和任务状态统计相关定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configGENERATE_RUN_TIME_STATS                   0                       <span class="comment">/* 1: 使能任务运行时间统计功能, 默认: 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> configGENERATE_RUN_TIME_STATS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./BSP/TIMER/btim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()        ConfigureTimeForRunTimeStats()</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> FreeRTOSRunTimeTicks;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portGET_RUN_TIME_COUNTER_VALUE()                FreeRTOSRunTimeTicks</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TRACE_FACILITY                        1                       <span class="comment">/* 1: 使能可视化跟踪调试, 默认: 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_STATS_FORMATTING_FUNCTIONS            1                       <span class="comment">/* 1: configUSE_TRACE_FACILITY为1时，会编译vTaskList()和vTaskGetRunTimeStats()函数, 默认: 0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 协程相关定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_CO_ROUTINES                           0                       <span class="comment">/* 1: 启用协程, 默认: 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_CO_ROUTINE_PRIORITIES                 2                       <span class="comment">/* 定义协程的最大优先级, 最大优先级=configMAX_CO_ROUTINE_PRIORITIES-1, 无默认configUSE_CO_ROUTINES为1时需定义 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 软件定时器相关定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TIMERS                                1                               <span class="comment">/* 1: 使能软件定时器, 默认: 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_TASK_PRIORITY                       ( configMAX_PRIORITIES - 1 )    <span class="comment">/* 定义软件定时器任务的优先级, 无默认configUSE_TIMERS为1时需定义 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_QUEUE_LENGTH                        5                               <span class="comment">/* 定义软件定时器命令队列的长度, 无默认configUSE_TIMERS为1时需定义 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_TASK_STACK_DEPTH                    ( configMINIMAL_STACK_SIZE * 2) <span class="comment">/* 定义软件定时器任务的栈空间大小, 无默认configUSE_TIMERS为1时需定义 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可选函数, 1: 使能 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskPrioritySet                        1                       <span class="comment">/* 设置任务优先级 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_uxTaskPriorityGet                       1                       <span class="comment">/* 获取任务优先级 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelete                             1                       <span class="comment">/* 删除任务 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskSuspend                            1                       <span class="comment">/* 挂起任务 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xResumeFromISR                          1                       <span class="comment">/* 恢复在中断中挂起的任务 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelayUntil                         1                       <span class="comment">/* 任务绝对延时 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelay                              1                       <span class="comment">/* 任务延时 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTaskGetSchedulerState                  1                       <span class="comment">/* 获取任务调度器状态 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTaskGetCurrentTaskHandle               1                       <span class="comment">/* 获取当前任务的任务句柄 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_uxTaskGetStackHighWaterMark             1                       <span class="comment">/* 获取任务堆栈历史剩余最小值 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTaskGetIdleTaskHandle                  1                       <span class="comment">/* 获取空闲任务的任务句柄 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_eTaskGetState                           1                       <span class="comment">/* 获取任务状态 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xEventGroupSetBitFromISR                1                       <span class="comment">/* 在中断中设置事件标志位 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTimerPendFunctionCall                  1                       <span class="comment">/* 将函数的执行挂到定时器服务任务 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTaskAbortDelay                         1                       <span class="comment">/* 中断任务延时 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTaskGetHandle                          1                       <span class="comment">/* 通过任务名获取任务句柄 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTaskResumeFromISR                      1                       <span class="comment">/* 恢复在中断中挂起的任务 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中断嵌套行为配置 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __NVIC_PRIO_BITS</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> configPRIO_BITS __NVIC_PRIO_BITS</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> configPRIO_BITS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configLIBRARY_LOWEST_INTERRUPT_PRIORITY         15                  <span class="comment">/* 中断最低优先级 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY    5                   <span class="comment">/* FreeRTOS可管理的最高中断优先级 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configKERNEL_INTERRUPT_PRIORITY                 ( configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_SYSCALL_INTERRUPT_PRIORITY            ( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_API_CALL_INTERRUPT_PRIORITY           configMAX_SYSCALL_INTERRUPT_PRIORITY</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* FreeRTOS中断服务函数相关定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xPortPendSVHandler                              PendSV_Handler</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vPortSVCHandler                                 SVC_Handler</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 断言 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vAssertCalled(char, int) printf(<span class="string">&quot;Error: %s, %d\r\n&quot;</span>, char, int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configASSERT( x ) <span class="keyword">if</span>( ( x ) == 0 ) vAssertCalled( __FILE__, __LINE__ )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* FreeRTOS MPU 特殊定义 */</span></span><br><span class="line"><span class="comment">//#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0</span></span><br><span class="line"><span class="comment">//#define configTOTAL_MPU_REGIONS                                8</span></span><br><span class="line"><span class="comment">//#define configTEX_S_C_B_FLASH                                  0x07UL</span></span><br><span class="line"><span class="comment">//#define configTEX_S_C_B_SRAM                                   0x07UL</span></span><br><span class="line"><span class="comment">//#define configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY            1</span></span><br><span class="line"><span class="comment">//#define configALLOW_UNPRIVILEGED_CRITICAL_SECTIONS             1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ARMv8-M 安全侧端口相关定义。 */</span></span><br><span class="line"><span class="comment">//#define secureconfigMAX_SECURE_CONTEXTS         5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* FREERTOS_CONFIG_H */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="任务的创建与删除"><a href="#任务的创建与删除" class="headerlink" title="任务的创建与删除"></a>任务的创建与删除</h2><h4 id="什么是任务？"><a href="#什么是任务？" class="headerlink" title="什么是任务？"></a>什么是任务？</h4><p>任务可以理解为进程&#x2F;线程，创建一个任务，就会在内存开辟一个空间。</p>
<p>任务可以被认为是一组函数，它们在运行时相互协作以完成特定的目标。</p>
<p>在 FreeROTS 中，任务可以分配不同的优先级，并按照优先级进行调度。当一个任务没有工作可以做时，操作系统会将 CPU 时间分配给另一个优先级更高的任务，以确保系统的正常运行。</p>
<p>任务通常都含有 while(1) 死循环。</p>
<h4 id="任务创建与删除相关函数"><a href="#任务创建与删除相关函数" class="headerlink" title="任务创建与删除相关函数"></a>任务创建与删除相关函数</h4><p><strong>任务创建与删除相关函数有如下三个：</strong></p>
<table>
<thead>
<tr>
<th><strong>函数名称</strong></th>
<th><strong>函数作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>xTaskCreate()</td>
<td>动态方式创建任务</td>
</tr>
<tr>
<td>xTaskCreateStatic()</td>
<td>静态方式创建任务</td>
</tr>
<tr>
<td>vTaskDelete()</td>
<td>删除任务</td>
</tr>
</tbody></table>
<p><strong>任务动态创建与静态创建的区别：</strong></p>
<p>动态创建任务的堆栈由系统分配，而静态创建任务的堆栈由用户自己传递。 通常情况下使用动态方式创建任务。</p>
<p><strong>xTaskCreate 函数原型</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240514192101116.png" alt="image-20240514192101116"></p>
<ol>
<li><p>pxTaskCode：指向任务函数的指针，任务必须实现为永不返回（即连续循环）；</p>
</li>
<li><p>pcName：任务的名字，主要是用来调试，默认情况下最大长度是16；</p>
</li>
<li><p>pvParameters：指定的任务栈的大小；</p>
</li>
<li><p>uxPriority：任务优先级，<strong>数值越大，优先级越大;</strong></p>
</li>
<li><p>pxCreatedTask：用于返回已创建任务的句柄可以被引用</p>
</li>
</ol>
<table>
<thead>
<tr>
<th><strong>返回值</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>pdPASS</td>
<td>任务创建成功</td>
</tr>
<tr>
<td>errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY</td>
<td>任务创建失败</td>
</tr>
</tbody></table>
<p><strong>vTaskDelete 函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">(TaskHandle_t xTaskToDelete)</span>;</span><br></pre></td></tr></table></figure>

<p>只需将待删除的任务句柄传入该函数，即可将该任务删除。</p>
<p>当传入的参数为NULL，则代表删除任务自身（当前正在运行的任务）。</p>
<h4 id="创建两个任务进行点灯实操"><a href="#创建两个任务进行点灯实操" class="headerlink" title="创建两个任务进行点灯实操"></a>创建两个任务进行点灯实操</h4><ol>
<li><p>增加两个任务，一个用于点亮LED1，一个用于点亮LED2</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240514194134071.png" alt="image-20240514194134071"></p>
</li>
<li><p>查看原理图，设置两个LED灯的引脚为输出引脚</p>
</li>
<li><p>导出代码后加入下面代码，编译烧录32单片机</p>
<p>freertos.c文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*任务1函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartTaskLED1</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">	HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_8);</span><br><span class="line">    osDelay(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*任务2函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartTaskLED2</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">	HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_9);</span><br><span class="line">    osDelay(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><h4 id="什么是任务调度？"><a href="#什么是任务调度？" class="headerlink" title="什么是任务调度？"></a>什么是任务调度？</h4><p>调度器就是使用相关的调度算法来决定当前需要执行的哪个任务。</p>
<p>FreeRTOS中开启任务调度的函数是 vTaskStartScheduler() ，但在 CubeMX 中被封装为 osKernelStart() </p>
<h4 id="FreeRTOS的任务调度规则是怎样的？"><a href="#FreeRTOS的任务调度规则是怎样的？" class="headerlink" title="FreeRTOS的任务调度规则是怎样的？"></a>FreeRTOS的任务调度规则是怎样的？</h4><ol>
<li>高优先级抢占低优先级任务，系统永远执行最高优先级的任务（即<strong>抢占式调度</strong>）</li>
<li>同等优先级的任务轮转调度（即<strong>时间片调度</strong>）</li>
<li><strong>携程式调度</strong>：但官方已明确表示不更新，主要是用在小容量的芯片上，用得 也不多。</li>
</ol>
<h4 id="抢占式调度运行过程"><a href="#抢占式调度运行过程" class="headerlink" title="抢占式调度运行过程"></a>抢占式调度运行过程</h4><p><strong>前提：</strong>任务优先级不同</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240514200647406.png" alt="image-20240514200647406"></p>
<p><strong>总结：</strong></p>
<ol>
<li>高优先级任务，优先执行；</li>
<li>高优先级任务不停止，低优先级任务无法执行；</li>
<li>被抢占的任务将会进入就绪态</li>
</ol>
<h4 id="时间片调度运行过程"><a href="#时间片调度运行过程" class="headerlink" title="时间片调度运行过程"></a>时间片调度运行过程</h4><p><strong>前提：</strong>任务优先级相同</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240514200748707.png" alt="image-20240514200748707"></p>
<p><strong>总结：</strong></p>
<ol>
<li>同等优先级任务，轮流执行，时间片流转；</li>
<li>一个时间片大小，取决为滴答定时器中断周期（默认1ms）；</li>
<li>注意没有用完的时间片不会再使用，下次任务 Task3 得到执行，还是按照一个时间片的时钟 节拍运行</li>
</ol>
<h2 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h2><p>FreeRTOS中任务共存在<code>4种</code>状态：</p>
<p><strong>Running 运行态</strong><br>当任务处于实际运行状态称之为运行态，即CPU的使用权被这个任务占用（同一时间仅一个任务 处于运行态）。</p>
<p><strong>Ready 就绪态</strong><br>处于就绪态的任务是指那些能够运行（没有被阻塞和挂起），但是当前没有运行的任务，因为同优先级或更高优先级的任务正在运行。</p>
<p><strong>Blocked 阻塞态</strong><br>如果一个任务因延时，或等待信号量、消息队列、事件标志组等而处于的状态被称之为阻塞态。</p>
<p><strong>Suspended 挂起态</strong><br>类似暂停，通过调用函数 vTaskSuspend() 对指定任务进行挂起，挂起后这个任务将不被执行， 只有调用函数 xTaskResume() 才可以将这个任务从挂起态恢复。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="../imgs/FreeRTOS/image-20240514213639865.png" alt="image-20240514213639865" style="zoom:50%;" />

<h2 id="任务调度和任务的状态案例分析"><a href="#任务调度和任务的状态案例分析" class="headerlink" title="任务调度和任务的状态案例分析"></a>任务调度和任务的状态案例分析</h2><p>实验需求</p>
<p>创建 4 个任务：taskLED1，taskLED2，taskKEY1，taskKEY2，任务要求如下：</p>
<p>taskLED1：间隔 500ms 闪烁 LED1；</p>
<p>taskLED2：间隔 1000ms 闪烁 LED2；</p>
<p>taskKEY1：如果 taskLED1 存在，则按下 KEY1 后删除 taskLED1 ，否则创建 taskLED1 ；</p>
<p>taskKEY2：如果 taskLED2 正常运行，则按下 KEY2 后挂起 taskLED2 ，否则恢复 taskLED2。</p>
<p>uart.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> temp[<span class="number">1</span>] = &#123;ch&#125;;</span><br><span class="line">	HAL_UART_Transmit(&amp;huart1,temp,<span class="number">1</span>,<span class="number">0xffff</span>);</span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>freertos.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StartTaskLED1</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">		HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_8);</span><br><span class="line">    osDelay(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">StartTask02</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">		HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_9);</span><br><span class="line">    osDelay(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">StartTaskKey1</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">		<span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_RESET)</span><br><span class="line">		&#123;</span><br><span class="line">			osDelay(<span class="number">20</span>); <span class="comment">// 延时消抖</span></span><br><span class="line">            <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_RESET)</span><br><span class="line">            &#123;</span><br><span class="line">			    <span class="built_in">printf</span>(<span class="string">&quot;Key1 被按下\r\n&quot;</span>);</span><br><span class="line">			    <span class="keyword">if</span>(TaskLED1Handle == <span class="literal">NULL</span>)</span><br><span class="line">			    &#123;</span><br><span class="line">			    	<span class="built_in">printf</span>(<span class="string">&quot;任务1不存在，准备创建任务1\r\n&quot;</span>);</span><br><span class="line">				    osThreadDef(TaskLED1, StartTaskLED1, osPriorityNormal, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">				    TaskLED1Handle = osThreadCreate(osThread(TaskLED1), <span class="literal">NULL</span>);</span><br><span class="line">				    <span class="keyword">if</span>(TaskLED1Handle != <span class="literal">NULL</span>)</span><br><span class="line">				    &#123;</span><br><span class="line">				    	<span class="built_in">printf</span>(<span class="string">&quot;任务1创建成功\r\n&quot;</span>);</span><br><span class="line">				    &#125;</span><br><span class="line">			    &#125;</span><br><span class="line">			    <span class="keyword">else</span></span><br><span class="line">			    &#123;</span><br><span class="line">				    <span class="built_in">printf</span>(<span class="string">&quot;删除任务1\r\n&quot;</span>);</span><br><span class="line">				    osThreadTerminate(TaskLED1Handle);</span><br><span class="line">				    TaskLED1Handle = <span class="literal">NULL</span>;</span><br><span class="line">		    	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="keyword">while</span>(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_RESET);</span><br><span class="line">		&#125;</span><br><span class="line">        osDelay(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">StartTaskKey2</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> flag = <span class="number">0</span>;	</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">		<span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_1) == GPIO_PIN_RESET)</span><br><span class="line">		&#123;</span><br><span class="line">			osDelay(<span class="number">20</span>); <span class="comment">// 延时消抖</span></span><br><span class="line">            <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_1) == GPIO_PIN_RESET)</span><br><span class="line">            &#123;</span><br><span class="line">    			<span class="built_in">printf</span>(<span class="string">&quot;Key2 被按下\r\n&quot;</span>);</span><br><span class="line">		    	<span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">		    	&#123;</span><br><span class="line">			    	osThreadSuspend(TaskLED2Handle);</span><br><span class="line">			    	<span class="built_in">printf</span>(<span class="string">&quot;任务2被挂起暂停\r\n&quot;</span>);</span><br><span class="line">			    	flag = <span class="number">1</span>;</span><br><span class="line">			    &#125;</span><br><span class="line">			    <span class="keyword">else</span></span><br><span class="line">			    &#123;</span><br><span class="line">			    	osThreadResume(TaskLED2Handle);</span><br><span class="line">			    	<span class="built_in">printf</span>(<span class="string">&quot;任务2重新恢复\r\n&quot;</span>);</span><br><span class="line">			    	flag = <span class="number">0</span>;</span><br><span class="line">		    	&#125;</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="keyword">while</span>(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_1) == GPIO_PIN_RESET);</span><br><span class="line">		&#125;</span><br><span class="line">        osDelay(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="什么是队列？"><a href="#什么是队列？" class="headerlink" title="什么是队列？"></a>什么是队列？</h3><p>队列又称消息队列，是一种常用于任务间通信的数据结构，队列可以在任务与任务间、中断和任 务间传递信息。</p>
<p><strong>为什么不使用全局变量？</strong></p>
<p>如果使用全局变量，任务1修改了变量 a ，等待任务3处理，但任务3处理速度很慢，在处理数据的过程中，任务2有可能又修改了变量 a ，导致任务3有可能得到的不是正确的数据。</p>
<p>在这种情况下，就可以使用队列。任务1和任务2产生的数据放在流水线上，任务3可以慢慢一个个依次处理。</p>
<p><strong>关于队列的几个名词：</strong>创建队列时，需要指定队列长度及队列项目大小。</p>
<ul>
<li><p><strong>队列项目：</strong>队列中的每一个数据；</p>
</li>
<li><p><strong>队列长度：</strong>队列能够存储队列项目的最大数量；</p>
</li>
</ul>
<p><strong>消息队列特点</strong></p>
<ol>
<li><p>数据入队出队方式</p>
<p>通常采用<code>先进先出（FIFO）</code>的数据存储缓冲机制，即先入队的数据会先从队列中被读取。也可以配置为后进先出（LIFO）方式，但用得比较少。</p>
</li>
<li><p>数据传递方式<br>采用实际值传递，即将数据拷贝到队列中进行传递，也可以传递指针，在传递较大的数据的时候 采用指针传递。</p>
</li>
<li><p>多任务访问<br>队列不属于某个任务，任何任务和中断都可以向队列发送&#x2F;读取消息</p>
</li>
<li><p>出队、入队阻塞<br>当任务向一个队列发送消息时，可以指定一个阻塞时间，假设此时当队列已满无法入队。</p>
</li>
</ol>
<p>阻塞时间如果设置为：</p>
<ul>
<li>0：直接返回不会等待；</li>
<li>0~port_MAX_DELAY：等待设定的阻塞时间，若在该时间内还无法入队，超时后直接返回不再等待；</li>
<li>port_MAX_DELAY：死等，一直等到可以入队为止。出队阻塞与入队阻塞类似；</li>
</ul>
<h3 id="消息队列相关-API-函数"><a href="#消息队列相关-API-函数" class="headerlink" title="消息队列相关 API 函数"></a>消息队列相关 API 函数</h3><h4 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle_t <span class="title function_">xQueueCreate</span><span class="params">( UBaseType_t uxQueueLength,UBaseType_t uxItemSize )</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>uxQueueLength：队列可同时容纳的最大项目数 。</li>
<li>uxItemSize：存储队列中的每个数据项所需的大小（以字节为单位）。</li>
</ul>
<p><strong>返回值</strong>： 如果队列创建成功，则返回所创建队列的句柄 。 如果创建队列所需的内存无法分配 ， 则返回 NULL。</p>
<h4 id="写队列"><a href="#写队列" class="headerlink" title="写队列"></a>写队列</h4><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>xQueueSend()</td>
<td>往队列的尾部写入消息</td>
</tr>
<tr>
<td>xQueueSendToBack()</td>
<td>同 xQueueSend()</td>
</tr>
<tr>
<td>xQueueSendToFront()</td>
<td>往队列的头部写入消息</td>
</tr>
<tr>
<td>xQueueOverwrite()</td>
<td>覆写队列消息（只用于队列长度为 1 的情况）</td>
</tr>
<tr>
<td>xQueueSendFromISR()</td>
<td>在中断中往队列的尾部写入消息</td>
</tr>
<tr>
<td>xQueueSendToBackFromISR()</td>
<td>同 xQueueSendFromISR()</td>
</tr>
<tr>
<td>xQueueSendToFrontFromISR()</td>
<td>在中断中往队列的头部写入消息</td>
</tr>
<tr>
<td>xQueueOverwriteFromISR()</td>
<td>在中断中覆写队列消息（只用于队列长度为 1 的情况）</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSend</span><span class="params">(</span></span><br><span class="line"><span class="params">                        QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">void</span> * pvItemToQueue,</span></span><br><span class="line"><span class="params">                        TickType_t xTicksToWait</span></span><br><span class="line"><span class="params">                    )</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>xQueue：队列的句柄，数据项将发送到此队列。</li>
<li>pvItemToQueue：待写入数据</li>
<li>xTicksToWait：阻塞超时时间</li>
</ul>
<p><strong>返回值：</strong></p>
<p>如果成功写入数据，返回 pdTRUE，否则返回 errQUEUE_FULL。</p>
<h4 id="读队列"><a href="#读队列" class="headerlink" title="读队列"></a>读队列</h4><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>xQueueReceive()</td>
<td>从队列头部读取消息，并删除消息</td>
</tr>
<tr>
<td>xQueuePeek()</td>
<td>从队列头部读取消息，但是不删除消息</td>
</tr>
<tr>
<td>xQueueReceiveFromISR()</td>
<td>在中断中从队列头部读取消息，并删除消息</td>
</tr>
<tr>
<td>xQueuePeekFromISR()</td>
<td>在中断中从队列头部读取消息</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueReceive</span><span class="params">(</span></span><br><span class="line"><span class="params">                            QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                            <span class="type">void</span> *pvBuffer,</span></span><br><span class="line"><span class="params">                            TickType_t xTicksToWait</span></span><br><span class="line"><span class="params">                    )</span>;</span><br></pre></td></tr></table></figure>


<p>​	<strong>参数：</strong></p>
<ul>
<li>xQueue：待读取的队列</li>
<li>pvItemToQueue：数据读取缓冲区</li>
<li>xTicksToWait：阻塞超时时间</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>成功返回 pdTRUE</li>
<li>否则返回 pdFALSE</li>
</ul>
<p>​	</p>
<h3 id="消息队列实操"><a href="#消息队列实操" class="headerlink" title="消息队列实操"></a>消息队列实操</h3><p><strong>要求：</strong>创建一个队列，按下 KEY1 向队列发送数据，按下 KEY2 向队列读取数据。</p>
<ol>
<li><p>然后创建两个任务和一个队列</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240515173834186.png" alt="image-20240515173834186"></p>
</li>
<li><p>设置按键引脚为输入，然后导出代码</p>
<p>freertos.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*用于监听Key1，Key1按下向队列发送消息*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartSend</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN StartSend */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">    <span class="type">uint16_t</span> buf = <span class="number">100</span>;</span><br><span class="line">    BaseType_t status;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            osDelay(<span class="number">20</span>);    <span class="comment">//消抖</span></span><br><span class="line">            <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET)</span><br><span class="line">            &#123;</span><br><span class="line">                status = xQueueSend(myQueue01Handle,&amp;buf,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(status == pdTRUE)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;写入队列成功\r\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;写入队列失败\r\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET);</span><br><span class="line">        &#125;</span><br><span class="line">    osDelay(<span class="number">10</span>);    <span class="comment">//10ms检测一次</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END StartSend */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*用于监听key2，key2按下从队列中读出消息*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartReceive</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN StartReceive */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">    <span class="type">uint16_t</span> buf = <span class="number">100</span>;</span><br><span class="line">    BaseType_t status;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            osDelay(<span class="number">20</span>);    <span class="comment">//消抖</span></span><br><span class="line">            <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET)</span><br><span class="line">            &#123;</span><br><span class="line">                status = xQueueReceive(myQueue01Handle,&amp;buf,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(status == pdTRUE)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;读出队列成功\r\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;读出队列失败\r\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET);</span><br><span class="line">        &#125;</span><br><span class="line">        osDelay(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END StartReceive */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240515175549520.png" alt="image-20240515175549520"></p>
</li>
</ol>
<h2 id="二值信号量"><a href="#二值信号量" class="headerlink" title="二值信号量"></a>二值信号量</h2><h3 id="什么是信号量？"><a href="#什么是信号量？" class="headerlink" title="什么是信号量？"></a>什么是信号量？</h3><p>信号量（Semaphore），是在多任务环境下使用的一种机制，是可以用来保证两个或多个关键代 码段不被并发调用。</p>
<p>信号量这个名字，我们可以把它拆分来看，信号可以起到通知信号的作用，然后我们的量还可以 用来表示资源的数量，当我们的量只有0和1的时候，它就可以被称作二值信号量，只有两个状 态，当我们的那个量没有限制的时候，它就可以被称作为计数型信号量。</p>
<p>信号量也是队列的一种。</p>
<h3 id="什么是二值信号量？"><a href="#什么是二值信号量？" class="headerlink" title="什么是二值信号量？"></a>什么是二值信号量？</h3><p>二值信号量其实就是一个长度为1，大小为零的队列，只有0和1两种状态，通常情况下，我们用它来进行互斥访问或任务同步。</p>
<p>互斥访问：比如门跟钥匙，只有获取到钥匙才可以开门</p>
<p>任务同步：比如录完视频后才能看视频</p>
<h3 id="二值信号量相关-API-函数"><a href="#二值信号量相关-API-函数" class="headerlink" title="二值信号量相关 API 函数"></a>二值信号量相关 API 函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>xSemaphoreCreateBinary()</td>
<td>使用动态方式创建二值信号量</td>
</tr>
<tr>
<td>xSemaphoreCreateBinaryStatic()</td>
<td>使用静态方式创建二值信号量</td>
</tr>
<tr>
<td>xSemaphoreGive()</td>
<td>释放信号量</td>
</tr>
<tr>
<td>xSemaphoreGiveFromISR()</td>
<td>在中断中释放信号量</td>
</tr>
<tr>
<td>xSemaphoreTake()</td>
<td>获取信号量</td>
</tr>
<tr>
<td>xSemaphoreTakeFromISR()</td>
<td>在中断中获取信号量</td>
</tr>
</tbody></table>
<h4 id="创建二值信号量"><a href="#创建二值信号量" class="headerlink" title="创建二值信号量"></a>创建二值信号量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateBinary</span><span class="params">( <span class="type">void</span> )</span></span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>无</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>成功，返回对应二值信号量的句柄；</li>
<li>失败，返回 NULL 。</li>
</ul>
<p><code>注意：</code>创建信号量时默认会释放</p>
<h4 id="释放二值信号量"><a href="#释放二值信号量" class="headerlink" title="释放二值信号量"></a>释放二值信号量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreGive</span><span class="params">( SemaphoreHandle_t xSemaphore )</span></span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>xSemaphore：要释放的信号量句柄</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>成功，返回 pdPASS ；</li>
<li>失败，返回 errQUEUE_FULL 。</li>
</ul>
<h4 id="获取二值信号量"><a href="#获取二值信号量" class="headerlink" title="获取二值信号量"></a>获取二值信号量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreTake</span><span class="params">( SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                    		TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>xSemaphore：要获取的信号量句柄</li>
<li>xTicksToWait：超时时间，0 表示不超时，portMAX_DELAY表示卡死等待；</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>成功，返回 pdPASS ；</li>
<li>失败，返回 errQUEUE_FULL 。</li>
</ul>
<h3 id="二值信号量实操"><a href="#二值信号量实操" class="headerlink" title="二值信号量实操"></a>二值信号量实操</h3><p><strong>实验需求</strong>：创建一个二值信号量，按下 KEY1 则释放信号量，按下 KEY2 获取信号量。</p>
<ol>
<li><p>打开CubeMX，创建两个任务用来放入和获取信号量</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240515192640377.png" alt="image-20240515192640377"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240515192712965.png" alt="image-20240515192712965"></p>
</li>
<li><p>进行代码编写</p>
<p>freertos.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*检测Key1，Key1按下释放信号量*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartKey01</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN StartKey01 */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">    BaseType_t status;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            osDelay(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET)</span><br><span class="line">            &#123;</span><br><span class="line">                status = xSemaphoreGive(myBinarySem01Handle);</span><br><span class="line">                <span class="keyword">if</span>(status == pdTRUE)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;释放二值信号量成功\r\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;释放二值信号量失败\r\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET);</span><br><span class="line">        &#125;</span><br><span class="line">        osDelay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END StartKey01 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*检测Key2，Ke21按下获取信号量*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartKey2</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN StartKey2 */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">    BaseType_t status;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            osDelay(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET)</span><br><span class="line">            &#123;</span><br><span class="line">                status = xSemaphoreTake(myBinarySem01Handle,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(status == pdTRUE)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;获取二值信号量成功\r\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;获取二值信号量失败\r\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET);</span><br><span class="line">        &#125;</span><br><span class="line">        osDelay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END StartKey2 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>串口调试：创建信号时默认会释放一次</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240515193554629.png" alt="image-20240515193554629"></p>
</li>
</ol>
<h2 id="计数型信号量"><a href="#计数型信号量" class="headerlink" title="计数型信号量"></a>计数型信号量</h2><h3 id="什么是计数型信号量？"><a href="#什么是计数型信号量？" class="headerlink" title="什么是计数型信号量？"></a>什么是计数型信号量？</h3><p>计数型信号量相当于队列长度大于1 的队列，因此计数型信号量能够容纳多个资源，这在计数型信号量被创建的时候确定的。</p>
<p>使用计数型信号量可以解决多个任务之间的同步问题，例如控制对共享资源的访问和协调任务的执行顺序。</p>
<h3 id="计数型信号量相关-API-函数"><a href="#计数型信号量相关-API-函数" class="headerlink" title="计数型信号量相关 API 函数"></a>计数型信号量相关 API 函数</h3><p>计数型信号量的释放和获取与二值信号量完全相同 ！  </p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>xSemaphoreCreateCounting()</td>
<td>使用动态方法创建计数型信号量</td>
</tr>
<tr>
<td>xSemaphoreCreateCountingStatic()</td>
<td>使用静态方法创建计数型信号量</td>
</tr>
<tr>
<td>uxSemaphoreGetCount()</td>
<td>获取信号量的计数值</td>
</tr>
</tbody></table>
<h4 id="创建计数型信号量"><a href="#创建计数型信号量" class="headerlink" title="创建计数型信号量"></a>创建计数型信号量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCounting</span><span class="params">( UBaseType_t uxMaxCount,</span></span><br><span class="line"><span class="params">                                         UBaseType_t uxInitialCount)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>uxMaxCount：可以达到的最大计数值</li>
<li>uxInitialCount：创建信号量时分配给信号量的计数值</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li><p>成功，返回对应计数型信号量的句柄；</p>
</li>
<li><p>失败，返回 NULL 。</p>
</li>
</ul>
<h4 id="释放计数型信号量"><a href="#释放计数型信号量" class="headerlink" title="释放计数型信号量"></a>释放计数型信号量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreGive</span><span class="params">( SemaphoreHandle_t xSemaphore )</span></span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>xSemaphore：要释放的信号量句柄</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li><p>成功，返回 pdPASS ；</p>
</li>
<li><p>失败，返回 errQUEUE_FULL 。</p>
</li>
</ul>
<h4 id="获取计数型信号量"><a href="#获取计数型信号量" class="headerlink" title="获取计数型信号量"></a>获取计数型信号量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreTake</span><span class="params">( SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                    TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>xSemaphore：要获取的信号量句柄</li>
<li>xTicksToWait：超时时间，0 表示不超时，portMAX_DELAY表示卡死等待；</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>成功，返回 pdPASS ；</li>
<li>失败，返回 errQUEUE_FULL 。</li>
</ul>
<h3 id="计数型信号量实操"><a href="#计数型信号量实操" class="headerlink" title="计数型信号量实操"></a>计数型信号量实操</h3><ol>
<li><p>打开CubeMX，创建两个任务和设置按键引脚为输入，通过按键来放入和获取信号量</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240515205540921.png" alt="image-20240515205540921"></p>
</li>
<li><p>使能计数信号量</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240515205613351.png" alt="image-20240515205613351"></p>
</li>
<li><p>创建一个计数信号量，设置最多存放3个信号量</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240515205656296.png" alt="image-20240515205656296"></p>
</li>
<li><p>进行代码编写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*监听Key1，Key1按下释放计数型信号量*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartKey01</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN StartKey01 */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">    BaseType_t status;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            osDelay(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET)</span><br><span class="line">            &#123;</span><br><span class="line">                status = xSemaphoreGive(myCountingSem01Handle);</span><br><span class="line">                <span class="keyword">if</span>(status == pdTRUE)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;释放计数型信号量成功\r\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;释放计数型信号量失败\r\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET);</span><br><span class="line">        &#125;</span><br><span class="line">        osDelay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END StartKey01 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*监听Key2，Key2按下获取计数型信号量*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartKey2</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN StartKey2 */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">    BaseType_t status;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            osDelay(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET)</span><br><span class="line">            &#123;</span><br><span class="line">                status = xSemaphoreTake(myCountingSem01Handle,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(status == pdTRUE)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;获取计数型信号量成功\r\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;获取计数型信号量失败\r\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET);</span><br><span class="line">        &#125;</span><br><span class="line">        osDelay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END StartKey2 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>串口调试</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240515211057039.png" alt="image-20240515211057039"></p>
</li>
</ol>
<h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><h3 id="什么是互斥量？"><a href="#什么是互斥量？" class="headerlink" title="什么是互斥量？"></a>什么是互斥量？</h3><p>在多数情况下，互斥型信号量和二值型信号量非常相似，但是从功能上二值型信号量用于同步， 而互斥型信号量用于资源保护。</p>
<p>互斥型信号量和二值型信号量还有一个最大的区别，互斥型信号量可以有效解决优先级反转现 象。</p>
<h3 id="什么是优先级反转（翻转）和优先级继承"><a href="#什么是优先级反转（翻转）和优先级继承" class="headerlink" title="什么是优先级反转（翻转）和优先级继承"></a>什么是优先级反转（翻转）和优先级继承</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240515215626013.png" alt="image-20240515215626013"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240515220054708.png" alt="image-20240515220054708"></p>
<p>以上图为例，系统中有3个不同优先级的任务H&#x2F;M&#x2F;L，最高优先级任务H和最低优先级任务L通过 信号量机制，共享资源。目前任务L占有资源，锁定了信号量，Task H运行后将被阻塞，直到Task L释放信号量后，Task H才能够退出阻塞状态继续运行。但是Task H在等待Task L释放信号量的过 程中，中等优先级任务M抢占了任务L，从而延迟了信号量的释放时间，导致Task H阻塞了更长时 间，这种现象称为优先级倒置或优先级反转（翻转）。</p>
<p><strong>优先级继承：</strong></p>
<p>当一个互斥信号量正在被一个低优先级的任务持有时， 如果此时有个高优先级的任 务也尝试获取这个互斥信号量，那么这个高优先级的任务就会被阻塞。不过这个高优先级的任务 会将低优先级任务的优先级提升到与自己相同的优先级。</p>
<p>优先级继承并不能完全的消除优先级翻转的问题，它只是尽可能的降低优先级翻转带来的影响。</p>
<h3 id="互斥量相关-API-函数"><a href="#互斥量相关-API-函数" class="headerlink" title="互斥量相关 API 函数"></a>互斥量相关 API 函数</h3><p>互斥信号量不能用于中断服务函数中！</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>xSemaphoreCreateMutex()</td>
<td>使用动态方法创建互斥信号量</td>
</tr>
<tr>
<td>xSemaphoreCreateMutexStatic()</td>
<td>使用静态方法创建互斥信号量</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateMutex</span><span class="params">( <span class="type">void</span> )</span></span><br></pre></td></tr></table></figure>
<p><strong>参数：</strong></p>
<ul>
<li>无</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li><p>成功，返回对应互斥量的句柄；</p>
</li>
<li><p>失败，返回 NULL 。</p>
</li>
</ul>
<h3 id="优先级反转（翻转）示例"><a href="#优先级反转（翻转）示例" class="headerlink" title="优先级反转（翻转）示例"></a>优先级反转（翻转）示例</h3><p>如下图，低优先级工作后高优先级被阻塞，然后发生优先级反转，中优先级比高优先级先工作</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240515222018960.png" alt="image-20240515222018960"></p>
<ol>
<li><p>打开CubeMX，增加三个任务，优先级分别从高到低</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240515224826392.png" alt="image-20240515224826392"></p>
</li>
<li><p>增加一个二值信号量</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240515224749188.png" alt="image-20240515224749188"></p>
</li>
<li><p>代码编写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StartTaskH</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN StartTaskH */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">        xSemaphoreTake(myBinarySem01Handle,portMAX_DELAY);  <span class="comment">//获取二值信号量</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;高优先级获得二值信号量，开始工作\r\n&quot;</span>);</span><br><span class="line">        HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;工作完毕后，释放二值信号量\r\n&quot;</span>);</span><br><span class="line">        xSemaphoreGive(myBinarySem01Handle);    <span class="comment">//释放二值信号量</span></span><br><span class="line">        osDelay(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END StartTaskH */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartTaskM</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN StartTaskM */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;占用cpu资源，我就是玩\r\n&quot;</span>);</span><br><span class="line">    osDelay(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END StartTaskM */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartTaskL</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN StartTaskL */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">        xSemaphoreTake(myBinarySem01Handle,portMAX_DELAY);  <span class="comment">//获取二值信号量</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;低优先级获得二值信号量，开始工作\r\n&quot;</span>);</span><br><span class="line">        HAL_Delay(<span class="number">3000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;工作完毕后，释放二值信号量\r\n&quot;</span>);</span><br><span class="line">        xSemaphoreGive(myBinarySem01Handle);    <span class="comment">//释放二值信号量</span></span><br><span class="line">        osDelay(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END StartTaskL */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>串口调试</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240515224636011.png" alt="image-20240515224636011"></p>
</li>
</ol>
<h3 id="使用互斥量优化优先级反转（翻转）问题示例"><a href="#使用互斥量优化优先级反转（翻转）问题示例" class="headerlink" title="使用互斥量优化优先级反转（翻转）问题示例"></a>使用互斥量优化优先级反转（翻转）问题示例</h3><ol>
<li><p>使用CubeMX在优先级反转示例中增加互斥量，导出代码、</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240515225515383.png" alt="image-20240515225515383"></p>
</li>
<li><p>编写代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StartTaskH</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN StartTaskH */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">        xSemaphoreTake(myMutex01Handle,portMAX_DELAY);  <span class="comment">//获取二值信号量</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;高优先级获得二值信号量，开始工作\r\n&quot;</span>);</span><br><span class="line">        HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;工作完毕后，释放二值信号量\r\n&quot;</span>);</span><br><span class="line">        xSemaphoreGive(myMutex01Handle);    <span class="comment">//释放二值信号量</span></span><br><span class="line">        osDelay(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END StartTaskH */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartTaskM</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN StartTaskM */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;占用cpu资源，我就是玩\r\n&quot;</span>);</span><br><span class="line">    osDelay(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END StartTaskM */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartTaskL</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN StartTaskL */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">        xSemaphoreTake(myMutex01Handle,portMAX_DELAY);  <span class="comment">//获取二值信号量</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;低优先级获得二值信号量，开始工作\r\n&quot;</span>);</span><br><span class="line">        HAL_Delay(<span class="number">3000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;工作完毕后，释放二值信号量\r\n&quot;</span>);</span><br><span class="line">        xSemaphoreGive(myMutex01Handle);    <span class="comment">//释放二值信号量</span></span><br><span class="line">        osDelay(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END StartTaskL */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>串口调试</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240515225403415.png" alt="image-20240515225403415"></p>
</li>
</ol>
<h2 id="事件标志组"><a href="#事件标志组" class="headerlink" title="事件标志组"></a>事件标志组</h2><h3 id="什么是事件标志组？"><a href="#什么是事件标志组？" class="headerlink" title="什么是事件标志组？"></a>什么是事件标志组？</h3><p><strong>事件标志位</strong><br>表明某个事件是否发生，联想：全局变量 flag。通常按位表示，每一个位表示一个事件（高8位不算）</p>
<p><strong>事件标志组</strong><br>是一组事件标志位的集合， 可以简单的理解事件标志组，就是一个整数。</p>
<p>事件标志组本质是一个 16 位或 32 位无符号的数据类型 EventBits_t ，由 configUSE_16_BIT_TICKS 决定。</p>
<p>虽然使用了 32 位无符号的数据类型变量来存储事件标志， 但其中的高8位用作存储事件标志组的 控制信息，低 24 位用作存储事件标志 ，所以说一个事件组最多可以存储 24 个事件标志！</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240516091046694.png" alt="image-20240516091046694"></p>
<h3 id="事件标志组相关-API-函数"><a href="#事件标志组相关-API-函数" class="headerlink" title="事件标志组相关 API 函数"></a>事件标志组相关 API 函数</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">xEventGroupCreate()</td>
<td align="center">使用动态方式创建事件标志组</td>
</tr>
<tr>
<td align="center">xEventGroupCreateStatic()</td>
<td align="center">使用静态方式创建事件标志组</td>
</tr>
<tr>
<td align="center">xEventGroupClearBits()</td>
<td align="center">清零事件标志位</td>
</tr>
<tr>
<td align="center">xEventGroupClearBitsFromISR()</td>
<td align="center">在中断中清零事件标志位</td>
</tr>
<tr>
<td align="center">xEventGroupSetBits()</td>
<td align="center">设置事件标志位</td>
</tr>
<tr>
<td align="center">xEventGroupSetBitsFromISR()</td>
<td align="center">在中断中设置事件标志位</td>
</tr>
<tr>
<td align="center">xEventGroupWaitBits()</td>
<td align="center">等待事件标志位</td>
</tr>
</tbody></table>
<h4 id="创建事件标志组"><a href="#创建事件标志组" class="headerlink" title="创建事件标志组"></a>创建事件标志组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventGroupHandle_t <span class="title function_">xEventGroupCreate</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>无</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li><p>成功，返回对应事件标志组的句柄；</p>
</li>
<li><p>失败，返回 NULL</p>
</li>
</ul>
<h4 id="设置事件标志位"><a href="#设置事件标志位" class="headerlink" title="设置事件标志位"></a>设置事件标志位</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventBits_t <span class="title function_">xEventGroupSetBits</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> EventBits_t uxBitsToSet )</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>xEventGroup：对应事件组句柄。</li>
<li>uxBitsToSet：指定要在事件组中设置的一个或多个位的按位值。</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>设置之后事件组中的事件标志位值。</li>
</ul>
<h4 id="清除事件标志位"><a href="#清除事件标志位" class="headerlink" title="清除事件标志位"></a>清除事件标志位</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventBits_t <span class="title function_">xEventGroupClearBits</span><span class="params">(EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> EventBits_t uxBitsToClear )</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>xEventGroup：对应事件组句柄。</li>
<li>uxBitsToClear：指定要在事件组中清除的一个或多个位的按位 值。</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>清零之前事件组中事件标志位的值。</li>
</ul>
<h4 id="等待事件标志位"><a href="#等待事件标志位" class="headerlink" title="等待事件标志位"></a>等待事件标志位</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventBits_t <span class="title function_">xEventGroupWaitBits</span><span class="params">(</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> EventBits_t uxBitsToWaitFor,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> BaseType_t xClearOnExit,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> BaseType_t xWaitForAllBits,</span></span><br><span class="line"><span class="params">                        TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li><p>xEventGroup：对应的事件标志组句柄</p>
</li>
<li><p>uxBitsToWaitFor：指定事件组中要等待的一个或多个事件位的按位值</p>
</li>
<li><p>xClearOnExit：pdTRUE——清除对应事件位，pdFALSE——不清除</p>
</li>
<li><p>xWaitForAllBits：pdTRUE——所有等待事件位全为1（逻辑与），pdFALSE——等待的事件位有一个为1（逻辑或）</p>
</li>
<li><p>xTicksToWait：超时时间，0 表示不超时，portMAX_DELAY表示卡死等待</p>
</li>
</ul>
<p><strong>返回值：</strong></p>
<p>等待的事件标志位值：等待事件标志位成功，返回等待到的事件标志位</p>
<p>其他值：等待事件标志位失败，返回事件组中的事件标志位</p>
<h3 id="事件标志组实操"><a href="#事件标志组实操" class="headerlink" title="事件标志组实操"></a><strong>事件标志组实操</strong></h3><p>创建一个事件标志组和两个任务（ task1 和 task2），task1 检测按键，如果检测到 KEY1 和 KEY2 都按过，则执行 task2 。</p>
<ol>
<li><p>打开CubeMX，增加两个任务，配置两个输入引脚给按键Key1和Key2</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240516094556147.png" alt="image-20240516094556147"></p>
</li>
<li><p>在代码中创建一个事件标志组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义事件标志组句柄*/</span> </span><br><span class="line">EventGroupHandle_t eventGroupHandle;</span><br><span class="line"> <span class="comment">/*创建事件标志组*/</span></span><br><span class="line"> eventGroupHandle = xEventGroupCreate();</span><br></pre></td></tr></table></figure>
</li>
<li><p>task1 检测按键，如果检测到 KEY1 和 KEY2 都按过，则执行 task2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*检测Key1和Key2有没有按下，如果按下则设置相应的事件标志组位*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartTask1</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN StartTask1 */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检测Key1有无被按下，按下后设置事件标志组最低位</span></span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            osDelay(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;按键Key1按下\r\n&quot;</span>);</span><br><span class="line">                xEventGroupSetBits(eventGroupHandle,<span class="number">0x01</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检测Key2有无被按下，按下后设置事件标志组第二低位</span></span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            osDelay(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;按键Key2按下\r\n&quot;</span>);</span><br><span class="line">                xEventGroupSetBits(eventGroupHandle,<span class="number">0x02</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET);</span><br><span class="line">        &#125;</span><br><span class="line">        osDelay(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END StartTask1 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该任务用于等待事件标志组*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartTask2</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">    EventBits_t event_bit;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN StartTask2 */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        event_bit = xEventGroupWaitBits(eventGroupHandle,<span class="number">0x01</span>|<span class="number">0x02</span>,pdTRUE,pdTRUE,portMAX_DELAY);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;返回值：%#x，按键都按下，任务2执行了\r\n&quot;</span>,event_bit); <span class="comment">// %#x是带格式输出, 效果为在输出前加0x</span></span><br><span class="line">        osDelay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END StartTask2 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开串口助手看运行结果</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240516094841590.png" alt="image-20240516094841590"></p>
</li>
</ol>
<h2 id="任务通知"><a href="#任务通知" class="headerlink" title="任务通知"></a>任务通知</h2><h3 id="什么是任务通知？"><a href="#什么是任务通知？" class="headerlink" title="什么是任务通知？"></a>什么是任务通知？</h3><p>FreeRTOS 从版本 V8.2.0 开始提供任务通知这个功能，每个任务都有一个 32 位的通知值。按照 FreeRTOS 官方的说法，使用消息通知比通过二进制信号量方式解除阻塞任务快 45%， 并且更加 省内存（无需创建队列）。</p>
<p>在大多数情况下，任务通知可以替代二值信号量、计数信号量、事件标志组，可以替代长度为 1 的队列（可以保存一个 32 位整数或指针值），并且任务通知速度更快、使用的RAM更少！</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240516101425764.png" alt="image-20240516101425764"></p>
<p>任务一给任务二发送通知，其实就是任务一操作任务二的TCB里面的ulNotifiedValue，给它写入相应的值</p>
<p>任务都有一个结构体：任务控制块TCB，它里边有两个结构体成员变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">tskTaskControlBlock</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	… …</span><br><span class="line">    	<span class="meta">#<span class="keyword">if</span> ( configUSE_TASK_NOTIFICATIONS  ==  1 )</span></span><br><span class="line">        	<span class="keyword">volatile</span>  <span class="type">uint32_t</span>    ulNotifiedValue [ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class="line">        	<span class="keyword">volatile</span>  <span class="type">uint8_t</span>      ucNotifyState [ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class="line">    	endif</span><br><span class="line">	… …</span><br><span class="line">&#125; tskTCB;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  configTASK_NOTIFICATION_ARRAY_ENTRIES	1  	<span class="comment">/* 定义任务通知数组的大小, 默认: 1 */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>一个是 uint32_t 类型，用来表示通知值</li>
<li>一个是 uint8_t 类型，用来表示通知状态</li>
</ul>
<h3 id="发送通知给任务-："><a href="#发送通知给任务-：" class="headerlink" title="发送通知给任务 ："></a>发送通知给任务 ：</h3><p>通过对以下方式的合理使用，可以在一定场合下替代原本的队列、信号量、事件标志组等。</p>
<ul>
<li><p>发送消息给任务，如果有通知未读， 不覆盖通知值</p>
</li>
<li><p>发送消息给任务，直接覆盖通知值</p>
</li>
<li><p>发送消息给任务，设置通知值的一个或者多个位</p>
</li>
<li><p>发送消息给任务，递增通知值</p>
</li>
</ul>
<h3 id="任务通知的优势和劣势"><a href="#任务通知的优势和劣势" class="headerlink" title="任务通知的优势和劣势"></a>任务通知的优势和劣势</h3><p><strong>任务通知的优势</strong></p>
<ol>
<li>使用任务通知向任务发送事件或数据，比使用队列、事件标志组或信号量快得多。</li>
<li>使用其他方法时都要先创建对应的结构体，使用任务通知时无需额外创建结构体。</li>
</ol>
<p><strong>任务通知的劣势</strong></p>
<ol>
<li>只有任务可以等待通知，中断服务函数中不可以，因为中断没有 TCB 。</li>
<li>通知只能一对一，因为通知必须指定任务。</li>
<li>等待通知的任务可以被阻塞， 但是发送消息的任务，任何情况下都不会被阻塞等待。</li>
<li>任务通知是通过更新任务通知值来发送数据的，任务结构体中只有一个任务通知值，只能保 持一个数据。</li>
</ol>
<h3 id="任务通知相关-API-函数"><a href="#任务通知相关-API-函数" class="headerlink" title="任务通知相关 API 函数"></a>任务通知相关 API 函数</h3><h4 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h4><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>xTaskNotify()</td>
<td>发送通知，带有通知值</td>
</tr>
<tr>
<td>xTaskNotifyAndQuery()</td>
<td>发送通知，带有通知值并且保留接收任务的原通知值</td>
</tr>
<tr>
<td>xTaskNotifyGive()</td>
<td>发送通知，不带通知值</td>
</tr>
<tr>
<td>xTaskNotifyFromISR()</td>
<td>在中断中发送任务通知</td>
</tr>
<tr>
<td>xTaskNotifyAndQueryFromISR()</td>
<td>在中断中发送任务通知</td>
</tr>
<tr>
<td>vTaskNotifyGiveFromISR()</td>
<td>在中断中发送任务通知</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotify</span><span class="params">( TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                        <span class="type">uint32_t</span> ulValue,</span></span><br><span class="line"><span class="params">                        eNotifyAction eAction )</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li><p>xTaskToNotify：需要接收通知的任务句柄；</p>
</li>
<li><p>ulValue：用于更新接收任务通知值， 具体如何更新由形参 eAction 决定；</p>
</li>
<li><p>eAction：一个枚举，代表如何使用任务通知的值；</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>eNoAction</td>
<td>发送通知，但不更新值（参数ulValue未使用）</td>
</tr>
<tr>
<td>eSetBits</td>
<td>被通知任务的通知值按位或ulValue。（某些场景下可代替事件组，效率更高）</td>
</tr>
<tr>
<td>eIncrement</td>
<td>被通知任务的通知值增加1（参数ulValue未使用），相当于 xTaskNotifyGive</td>
</tr>
<tr>
<td>eSetValueWithOverwrite</td>
<td>被通知任务的通知值设置为 ulValue。（某些场景下可代替 xQueueOverwrite ，效率更高）</td>
</tr>
<tr>
<td>eSetValueWithoutOverwrite</td>
<td>如果被通知的任务当前没有通知，则被通知的任务的通知值设为ulValue。如果被通知任务没有取走上一个通知，又接收到了一个通 知，则这次通知值丢弃，在这种情况下视为调用失败并返回 pdFALSE，（某些场景下可代替 xQueueSend ，效率更高）</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>返回值：</strong>如果被通知任务还没取走上一个通知，又接收了一个通知，则这次通知值未能更新并返回 pdFALSE， 而其他情况均返回pdPASS。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotifyAndQuery</span><span class="params">( TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                                <span class="type">uint32_t</span> ulValue,</span></span><br><span class="line"><span class="params">                                eNotifyAction eAction,</span></span><br><span class="line"><span class="params">                                <span class="type">uint32_t</span> *pulPreviousNotifyValue )</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>xTaskToNotify：需要接收通知的任务句柄；</li>
<li>ulValue：用于更新接收任务通知值， 具体如何更新 由形参 eAction 决定；</li>
<li>eAction：一个枚举，代表如何使用任务通知的值；</li>
<li>pulPreviousNotifyValue：对象任务的上一个任务通知值，如果为 NULL， 则不需要回传， 这个时候就等价于函数 xTaskNotify()。</li>
</ul>
<p><strong>返回值：</strong></p>
<p>如果被通知任务还没取走上一个通知，又接收了一个通知，则这次通知值未能更新并返回 pdFALSE， 而其他情况均返回pdPASS。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotifyGive</span><span class="params">( TaskHandle_t xTaskToNotify )</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>xTaskToNotify：接收通知的任务句柄， 并让其自身的任务通知值加 1。</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>总是返回 pdPASS。</li>
</ul>
<h4 id="等待通知"><a href="#等待通知" class="headerlink" title="等待通知"></a>等待通知</h4><p>等待通知API函数只能用在任务，不可应用于中断中！</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ulTaskNotifyTake()</td>
<td>获取任务通知，可以设置在退出此函数的时候将任务通知值清零或者减 一。当任务通知用作二值信号量或者计数信号量的时候，使用此函数来 获取信号量。</td>
</tr>
<tr>
<td>xTaskNotifyWait()</td>
<td>获取任务通知，比 ulTaskNotifyTake()更为复杂，可获取通知值和清除通知值的指定位</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">ulTaskNotifyTake</span><span class="params">( BaseType_t xClearCountOnExit,</span></span><br><span class="line"><span class="params">                            TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>xClearCountOnExit：指定在成功接收通知后，将通知值清零或减 1，pdTRUE：把通知值清零（二值信号量）；pdFALSE：把通知值减一（计数型信号量）；</li>
<li>xTicksToWait：阻塞等待任务通知值的最大时间；超时时间，0 表示不超时，portMAX_DELAY表示卡死等待</li>
</ul>
<p><strong>返回值：</strong>0：接收失败；非0：接收成功，返回任务通知的通知值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotifyWait</span><span class="params">( <span class="type">uint32_t</span> ulBitsToClearOnEntry,</span></span><br><span class="line"><span class="params">                            <span class="type">uint32_t</span> ulBitsToClearOnExit,</span></span><br><span class="line"><span class="params">                            <span class="type">uint32_t</span> *pulNotificationValue,</span></span><br><span class="line"><span class="params">                            TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>ulBitsToClearOnEntry：函数执行前清零任务通知值那些位 。</li>
<li>ulBitsToClearOnExit：表示在函数退出前，清零任务通知值那些位，在清 0 前，接收到的任务通知值会先被保存到形参 *pulNotificationValue 中。</li>
<li>pulNotificationValue：用于保存接收到的任务通知值。 如果不需要使用，则设置为 NULL 即可</li>
<li>xTicksToWait：等待消息通知的最大等待时间。超时时间，0 表示不超时，portMAX_DELAY表示卡死等待</li>
</ul>
<h3 id="任务通知实操"><a href="#任务通知实操" class="headerlink" title="任务通知实操"></a>任务通知实操</h3><h4 id="模拟二值信号量"><a href="#模拟二值信号量" class="headerlink" title="模拟二值信号量"></a>模拟二值信号量</h4><ol>
<li><p>创建两个任务和设置按键引脚为输入</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240516153957454.png" alt="image-20240516153957454"></p>
</li>
<li><p>设置两个按键分别发送和接收二值信号量</p>
<p>用到函数</p>
<ul>
<li>xTaskNotifyGive()</li>
<li>ulTaskNotifyTake()</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StartTaskSend</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            osDelay(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET)</span><br><span class="line">            &#123;</span><br><span class="line">                xTaskNotifyGive(taskReceiveHandle);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;发送任务通知，模拟二值信号量释放\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET);</span><br><span class="line">        &#125;</span><br><span class="line">        osDelay(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartTaskReceive</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> rev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            osDelay(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET)</span><br><span class="line">            &#123;</span><br><span class="line">                rev = ulTaskNotifyTake(pdTRUE,portMAX_DELAY);</span><br><span class="line">                <span class="keyword">if</span>(rev != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;接收任务通知：模拟二值信号量接收\r\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET);</span><br><span class="line">        &#125;</span><br><span class="line">        osDelay(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>打开串口助手，查看结果</p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240516153931799.png" alt="image-20240516153931799"></p>
<h4 id="模拟计数型信号量"><a href="#模拟计数型信号量" class="headerlink" title="模拟计数型信号量"></a>模拟计数型信号量</h4><p>模拟计数型信号量跟模拟二值信号量基本相同：</p>
<p>将ulTaskNotifyTake()函数中第一个参数从<strong>pdTRUE</strong>改为<strong>pdFALSE</strong></p>
<p><strong>代码示例：</strong></p>
<p>用到函数</p>
<ul>
<li><p>xTaskNotifyGive()</p>
</li>
<li><p>ulTaskNotifyTake()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StartTaskSend</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            osDelay(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET)</span><br><span class="line">            &#123;</span><br><span class="line">                xTaskNotifyGive(taskReceiveHandle);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;发送任务通知，模拟计数型信号量释放\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET);</span><br><span class="line">        &#125;</span><br><span class="line">        osDelay(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartTaskReceive</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> rev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            osDelay(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET)</span><br><span class="line">            &#123;</span><br><span class="line">                rev = ulTaskNotifyTake(pdFALSE,portMAX_DELAY);</span><br><span class="line">                <span class="keyword">if</span>(rev != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;接收任务通知：模拟二值技术型信号量接收\r\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET);</span><br><span class="line">        &#125;</span><br><span class="line">        osDelay(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240516154537115.png" alt="image-20240516154537115"></p>
<h4 id="模拟事件标志组"><a href="#模拟事件标志组" class="headerlink" title="模拟事件标志组"></a>模拟事件标志组</h4><p>用到函数</p>
<ul>
<li>xTaskNotify()</li>
<li>xTaskNotifyWait()</li>
</ul>
<p>示例代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StartTaskSend</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN StartTaskSend */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            osDelay(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;将bit0位置1\r\n&quot;</span>);</span><br><span class="line">                xTaskNotify(taskReceiveHandle,<span class="number">0x01</span>,eSetBits);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            osDelay(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;将bit1位置1\r\n&quot;</span>);</span><br><span class="line">                xTaskNotify(taskReceiveHandle,<span class="number">0x02</span>,eSetBits);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET);</span><br><span class="line">        &#125;</span><br><span class="line">        osDelay(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END StartTaskSend */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartTaskReceive</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN StartTaskReceive */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">    <span class="type">uint32_t</span> notify_rev = <span class="number">0</span>, event_bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        xTaskNotifyWait(<span class="number">0</span>,<span class="number">0xFFFFFFFF</span>,&amp;notify_rev,portMAX_DELAY);</span><br><span class="line">        <span class="keyword">if</span>(notify_rev &amp; <span class="number">0x01</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            event_bit |= <span class="number">0x01</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(notify_rev &amp; <span class="number">0x02</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            event_bit |= <span class="number">0x02</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(event_bit == (<span class="number">0x01</span> | <span class="number">0x02</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;任务通知模拟事件标志组接收成功\r\n&quot;</span>);</span><br><span class="line">            event_bit = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	osDelay(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END StartTaskReceive */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240516155459322.png" alt="image-20240516155459322"></p>
<h4 id="模拟消息邮箱"><a href="#模拟消息邮箱" class="headerlink" title="模拟消息邮箱"></a>模拟消息邮箱</h4><p>模拟邮箱大概就是向任务发送数据，但是与队列不同，任务邮箱发送消息受到了很多限制。</p>
<ul>
<li>只能发送一个32位的值。</li>
<li>消息邮箱的值被保存为一个任务的通知值，而且只能保存一个任务的值，相当于队列长度为1</li>
</ul>
<p>用到函数</p>
<ul>
<li>xTaskNotify()</li>
<li>xTaskNotifyWait()</li>
</ul>
<p>示例代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StartTaskSend</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            osDelay(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;按键1按下\r\n&quot;</span>);</span><br><span class="line">                xTaskNotify(taskReceiveHandle,<span class="number">1</span>,eSetValueWithOverwrite);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == GPIO_PIN_RESET);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            osDelay(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;按键2按下\r\n&quot;</span>);</span><br><span class="line">                xTaskNotify(taskReceiveHandle,<span class="number">2</span>,eSetValueWithOverwrite);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_10) == GPIO_PIN_RESET);</span><br><span class="line">        &#125;</span><br><span class="line">        osDelay(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartTaskReceive</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> notify_rev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        xTaskNotifyWait(<span class="number">0</span>,<span class="number">0xFFFFFFFF</span>,&amp;notify_rev,portMAX_DELAY);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接收到的通知值为:%d\r\n&quot;</span>,notify_rev);</span><br><span class="line">        osDelay(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240516160133709.png" alt="image-20240516160133709"></p>
<h2 id="延时函数和软件定时器"><a href="#延时函数和软件定时器" class="headerlink" title="延时函数和软件定时器"></a>延时函数和软件定时器</h2><h3 id="什么是延时函数？"><a href="#什么是延时函数？" class="headerlink" title="什么是延时函数？"></a>什么是延时函数？</h3><p>延时函数是一种编程语言中常用的函数类型，用于暂停一段时间后再执行后续的操作。在延时函数执行期间，程序会暂停执行，直到指定的时间结束后才会继续执行后续代码。常见的延时函数参数是毫秒或微秒，可以控制真实时间和计算机时间的关系。延时函数常用于需要等待或暂停执行的场景，如控制程序运行速度、动画效果等。<br><strong>不过，过度使用延时函数可能会影响程序的性能和响应速度。</strong></p>
<h3 id="延时函数分类"><a href="#延时函数分类" class="headerlink" title="延时函数分类"></a>延时函数分类</h3><p>相对延时：vTaskDelay</p>
<p>绝对延时：vTaskDelayUntil</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="../imgs/FreeRTOS/image-20240516122605665.png" alt="image-20240516122605665" style="zoom:50%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="../imgs/FreeRTOS/image-20240516122700990.png" alt="image-20240516122700990" style="zoom:50%;" />

<p><strong>vTaskDelay 与 HAL_Delay 的区别</strong></p>
<p>vTaskDelay 作用是让任务阻塞，任务阻塞后，RTOS系统调用其它处于就绪状态的优先级最高的任 务来执行。</p>
<p>HAL_Delay 一直不停的调用获取系统时间的函数，直到指定的时间流逝然后退出，故其占用了全 部CPU时间。</p>
<h3 id="什么是定时器？"><a href="#什么是定时器？" class="headerlink" title="什么是定时器？"></a>什么是定时器？</h3><p>简单可以理解为闹钟，到达指定一段时间后，就会响铃。</p>
<p>STM32 芯片自带硬件定时器，精度较高，达到定时时间后会触发中断，也可以生成 PWM 、输入 捕获、输出比较，等等，功能强大，但是由于硬件的限制，个数有限。</p>
<p>软件定时器也可以实现定时功能，达到定时时间后可调用回调函数，可以在回调函数里处理信息。</p>
<p><strong>软件定时器优缺点</strong><br>        优点：</p>
<ol>
<li><p>简单、成本低；</p>
</li>
<li><p>只要内存足够，可创建多个；</p>
</li>
</ol>
<p>缺点：</p>
<p>精度较低，容易受中断影响。在大多数情况下够用，但对于精度要求比较高的场合不建议使用。</p>
<p><strong>软件定时器原理</strong></p>
<p>定时器是一个可选的、不属于 FreeRTOS 内核的功能，它是由定时器服务任务来提供的。</p>
<p>在调用函数 vTaskStartScheduler() 开启任务调度器的时候，会创建一个用于管理软件定时器的任 务，这个任务就叫做软件定时器服务任务。</p>
<ol>
<li><p>负责软件定时器超时的逻辑判断</p>
</li>
<li><p>调用超时软件定时器的超时回调函数</p>
</li>
<li><p>处理软件定时器命令队列</p>
</li>
</ol>
<p>FreeRTOS提供了很多定时器有关的API函数，这些API函数大多都使用FreeRTOS的队列发送命令给 定时器服务任务。这个队列叫做定时器命令队列。定时器命令队列是提供给FreeRTOS的软件定时器使用的，用户不能直接访问！</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240516124448580.png" alt="image-20240516124448580"></p>
<p><strong>软件定时器相关配置</strong></p>
<p>软件定时器有一个定时器服务任务和定时器命令队列，这两个东西肯定是要配置的，相关的配置 也是放到文件FreeRTOSConfig.h中的，涉及到的配置如下：</p>
<p>1、configUSE_TIMERS</p>
<p>如果要使用软件定时器的话宏configUSE_TIMERS一定要设置为1，当设置为1的话定时器服务任务 就会在启动FreeRTOS调度器的时候自动创建。</p>
<p>2、configTIMER_TASK_PRIORITY</p>
<p>设置软件定时器服务任务的任务优先级，可以为0~(configMAX_PRIORITIES-1)。优先级一定要根 据实际的应用要求来设置。如果定时器服务任务的优先级设置的高的话，定时器命令队列中的命 令和定时器回调函数就会及时的得到处理。</p>
<p>3、configTIMER_QUEUE_LENGTH</p>
<p>此宏用来设置定时器命令队列的队列长度。</p>
<p>4、configTIMER_TASK_STACK_DEPTH</p>
<p>此宏用来设置定时器服务任务的任务堆栈大小。</p>
<p><strong>单次定时器和周期定时器</strong></p>
<p>单次定时器： 只超时一次，调用一次回调函数。可手动再开启定时器；</p>
<p>周期定时器： 多次超时，多次调用回调函数。</p>
<h3 id="软件定时器相关-API-函数"><a href="#软件定时器相关-API-函数" class="headerlink" title="软件定时器相关 API 函数"></a>软件定时器相关 API 函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>xTimerCreate()</td>
<td>动态方式创建软件定时器</td>
</tr>
<tr>
<td>xTimerCreateStatic()</td>
<td>静态方式创建软件定时器</td>
</tr>
<tr>
<td>xTimerStart()</td>
<td>开启软件定时器定时</td>
</tr>
<tr>
<td>xTimerStop()</td>
<td>停止软件定时器定时</td>
</tr>
<tr>
<td>xTimerReset()</td>
<td>复位软件定时器定时</td>
</tr>
<tr>
<td>xTimerChangePeriod()</td>
<td>更改软件定时器的定时超时时间</td>
</tr>
<tr>
<td>xTimerStartFromISR()</td>
<td>在中断中开启软件定时器定时</td>
</tr>
<tr>
<td>xTimerStopFromISR()</td>
<td>在中断中停止软件定时器定时</td>
</tr>
<tr>
<td>xTimerResetFromISR()</td>
<td>在中断中复位软件定时器定时</td>
</tr>
<tr>
<td>xTimerChangePeriodFromISR()</td>
<td>在中断中更改定时超时时间</td>
</tr>
</tbody></table>
<h4 id="创建软件定时器"><a href="#创建软件定时器" class="headerlink" title="创建软件定时器"></a>创建软件定时器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TimerHandle_t <span class="title function_">xTimerCreate</span></span><br><span class="line">            <span class="params">(   <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcTimerName,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> TickType_t xTimerPeriod,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> UBaseType_t uxAutoReload,</span></span><br><span class="line"><span class="params">                <span class="type">void</span> * <span class="type">const</span> pvTimerID,</span></span><br><span class="line"><span class="params">                TimerCallbackFunction_t pxCallbackFunction )</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>pcTimerName：软件定时器名称</li>
<li>xTimerPeriodInTicks：定时超时时间，单位：系统时钟节拍。宏 pdMS_TO_TICKS() 可用于将以毫秒为单位指定的时间转换为以 tick 为单位指定的时间。</li>
<li>uxAutoReload：定时器模式， pdTRUE：周期定时器， pdFALSE：单次定时器</li>
<li>pvTimerID：软件 定时器 ID，用于多个软件定时器公用一个超时回调函数</li>
<li>pxCallbackFunction：软件定时器超时回调函数</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>成功：定时器句柄</li>
<li>失败：NULL</li>
</ul>
<h4 id="开启软件定时器"><a href="#开启软件定时器" class="headerlink" title="开启软件定时器"></a>开启软件定时器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTimerStart</span><span class="params">( TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                        TickType_t xBlockTime )</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>xTimer：待开启的软件定时器的句柄</li>
<li>xTickToWait：发送命令到软件定时器命令队列的最大等待时间</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>pdPASS：开启成功</li>
<li>pdFAIL：开启失败</li>
</ul>
<h4 id="停止软件定时器"><a href="#停止软件定时器" class="headerlink" title="停止软件定时器"></a>停止软件定时器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTimerStop</span><span class="params">( TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                        TickType_t xBlockTime )</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>xTimer：待开启的软件定时器的句柄</li>
<li>xTickToWait：发送命令到软件定时器命令队列的最大等待时间</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>pdPASS：开启成功</li>
<li>pdFAIL：开启失败</li>
</ul>
<h4 id="复位软件定时器"><a href="#复位软件定时器" class="headerlink" title="复位软件定时器"></a>复位软件定时器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTimerReset</span><span class="params">( TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                        TickType_t xBlockTime )</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>xTimer：待开启的软件定时器的句柄</li>
<li>xTickToWait：发送命令到软件定时器命令队列的最大等待时间</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>pdPASS：开启成功</li>
<li>pdFAIL：开启失败</li>
</ul>
<p>该功能将使软件定时器的重新开启定时，复位后的软件定时器以复位时的时刻作为开启时刻重新 定时。</p>
<h4 id="更改软件定时器定时时间"><a href="#更改软件定时器定时时间" class="headerlink" title="更改软件定时器定时时间"></a>更改软件定时器定时时间</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTimerChangePeriod</span><span class="params">( TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                                TickType_t xNewPeriod,</span></span><br><span class="line"><span class="params">                                TickType_t xBlockTime )</span>;</span><br></pre></td></tr></table></figure>

<p>xNewPeriod：新的定时超时时间，单位：系统时钟节拍。</p>
<p>其余参数与返回值同上。</p>
<h3 id="延时函数和软件定时器实操"><a href="#延时函数和软件定时器实操" class="headerlink" title="延时函数和软件定时器实操"></a>延时函数和软件定时器实操</h3><p>创建两个定时器：</p>
<p>定时器1，周期定时器，每1秒打印一次 ten</p>
<p>定时器2，单次定时器，启动后 2 秒打印一次 zzz</p>
<ol>
<li><p>使能软件定时器</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240516125318421.png" alt="image-20240516125318421"></p>
</li>
<li><p>创建两个定时器</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240516125505359.png" alt="image-20240516125505359"></p>
</li>
<li><p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StartTask1</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN StartTask1 */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">    xTimerStart(myTimer01Handle,<span class="number">1000</span>);  <span class="comment">//开启软件定时器1，定时时间为1s</span></span><br><span class="line">    xTimerStart(myTimer02Handle,<span class="number">2000</span>);  <span class="comment">//开启软件定时器2，定时时间为2s</span></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        osDelay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END StartTask1 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Callback01 function */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Callback01</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Callback01 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;周期定时器:ten\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END Callback01 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Callback02 function */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Callback02</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Callback02 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;单次定时器:zzz\r\n&quot;</span>);</span><br><span class="line">  <span class="comment">/* USER CODE END Callback02 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="中断管理"><a href="#中断管理" class="headerlink" title="中断管理"></a>中断管理</h2><h3 id="中断定义"><a href="#中断定义" class="headerlink" title="中断定义"></a>中断定义</h3><p>中断是指在程序执行的过程中，突然发生了某种事件，需要立即停止当前正在执行的程序，并转而处理这个事件，处理完后再回到原来的程序执行点继续执行的过程。</p>
<p>中断可以是硬件中断（由硬件设备触发）或软件中断（由程序执行中断指令触发）。</p>
<p>中断可以提高计算机的响应速度和效率，使得计算机可以同时处理多个任务。</p>
<h3 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h3><p>任何中断的优先级都大于任务！</p>
<p>在我们的操作系统，中断同样是具有优先级的，并且我们也可以设置它的优先级，但是他的优先 级并不是从 0<del>15 ，默认情况下它是从 5</del>15 ，0~4 这 5 个中断优先级不是 FreeRTOS 控制的（5是 取决于 configMAX_SYSCALL_INTERRUPT_PRIORITY）。</p>
<p><strong>相关注意</strong></p>
<ul>
<li><p>在中断中必需使用中断相关的函数；</p>
</li>
<li><p>中断服务函数运行时间越短越好。</p>
</li>
</ul>
<h3 id="中断相关函数"><a href="#中断相关函数" class="headerlink" title="中断相关函数"></a>中断相关函数</h3><h4 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h4><p>xQueueReceiveFromISR()：在中断中从队列头部读取消息，并删除消息<br>        xQueuePeekFromISR()：在中断中从队列头部读取消息</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>xSemaphoreGiveFromISR()：在中断中释放信号量<br>        xSemaphoreTakeFromISR()：在中断中获取信号量</p>
<h4 id="事件标志组-1"><a href="#事件标志组-1" class="headerlink" title="事件标志组"></a>事件标志组</h4><p>xEventGroupClearBitsFromISR()：在中断中清零事件标志位<br>        xEventGroupSetBitsFromISR()：在中断中设置事件标志位</p>
<h4 id="任务通知-1"><a href="#任务通知-1" class="headerlink" title="任务通知"></a>任务通知</h4><p>xTaskNotifyFromISR()：在中断中发送任务通知<br>        xTaskNotifyAndQueryFromISR()：在中断中发送任务通知<br>        vTaskNotifyGiveFromISR()：在中断中发送任务通知</p>
<h4 id="软件定时器"><a href="#软件定时器" class="headerlink" title="软件定时器"></a>软件定时器</h4><p>xTimerStartFromISR()：在中断中开启软件定时器定时<br>        xTimerStopFromISR()：在中断中停止软件定时器定时<br>        xTimerResetFromISR()：在中断中复位软件定时器定时<br>        xTimerChangePeriodFromISR()：在中断中更改定时超时时间</p>
<h3 id="中断管理实操"><a href="#中断管理实操" class="headerlink" title="中断管理实操"></a>中断管理实操</h3><p>创建一个队列及一个任务，按下按键 KEY1 触发中断，在中断服务函数里向队列里发送数据，任 务则阻塞接收队列数据。</p>
<ol>
<li><p>打开CubeMX，在NVIC中使能中断</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240516142953447.png" alt="image-20240516142953447"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240516143009298.png" alt="image-20240516143009298"></p>
</li>
<li><p>中断代码示例：</p>
<p>用到的中断函数：xQueueSendFromISR（）</p>
<p>stm32f1xx_it.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cmsis_os.h&quot;</span> <span class="comment">// 增加CubeMX封装好的头文件</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> osMessageQId myQueue01Handle;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> snd = <span class="number">1</span>;</span><br><span class="line">    xQueueSendFromISR(myQueue01Handle, &amp;snd, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>freertos.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StartTask1</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> rev;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (xQueueReceive(myQueue01Handle, &amp;rev, portMAX_DELAY) == pdTRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;rev = %d\r\n&quot;</span>, rev);</span><br><span class="line">        &#125;</span><br><span class="line">        osDelay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开串口助手，查看结果</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../imgs/FreeRTOS/image-20240516143953554.png" alt="image-20240516143953554"></p>
</li>
</ol>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/04/29/XJZajStb.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/04/29/XJZajStb.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Ten</div><div class="post-copyright__author_desc">记得给自己磕头</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2024/05/13/FreeRTOS/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2024/05/13/FreeRTOS/')">FreeRTOS</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://img2.imgtp.com/2024/04/29/ZLUmR1ch.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/04/29/ZLUmR1ch.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://img2.imgtp.com/2024/04/29/jhBLTmH3.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/04/29/jhBLTmH3.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2024/05/13/FreeRTOS/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=FreeRTOS&amp;url=http://example.com/2024/05/13/FreeRTOS/&amp;pic=https://img2.imgtp.com/2024/05/13/IAYeaBKD.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Ten-zzZ</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/FreeRTOS/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>FreeRTOS<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://img2.imgtp.com/2024/05/13/IAYeaBKD.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2024/05/13/ADC%E5%92%8CDMA/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/05/13/dLVYfxUA.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ADC和DMA</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/04/29/XJZajStb.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">欢迎来到我的嵌入式学习笔记！这里是我作为一个初学者的探索记录，我们一起从零开始，一步步解开嵌入式的神秘面纱。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Ten</h1><div class="author-info__desc">记得给自己磕头</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/Ten-zzZ" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/352659041" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E8%AF%86FreeRTOS"><span class="toc-number">1.</span> <span class="toc-text">初识FreeRTOS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFFreeRTOS"><span class="toc-number">1.1.</span> <span class="toc-text">什么是FreeRTOS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9FreeRTOS"><span class="toc-number">1.2.</span> <span class="toc-text">为什么选择FreeRTOS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FreeRTOS%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.3.</span> <span class="toc-text">FreeRTOS的特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FreeRTOS%E7%A7%BB%E6%A4%8D"><span class="toc-number">2.</span> <span class="toc-text">FreeRTOS移植</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8CubeMX%E5%BF%AB%E9%80%9F%E7%A7%BB%E6%A4%8D"><span class="toc-number">2.1.</span> <span class="toc-text">使用CubeMX快速移植</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FreeRTOS%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE"><span class="toc-number">3.</span> <span class="toc-text">FreeRTOS系统配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FreeRTOSConfig-h-%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text">FreeRTOSConfig.h 文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="toc-number">4.</span> <span class="toc-text">任务的创建与删除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%BB%E5%8A%A1%EF%BC%9F"><span class="toc-number">4.0.1.</span> <span class="toc-text">什么是任务？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">4.0.2.</span> <span class="toc-text">任务创建与删除相关函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%A4%E4%B8%AA%E4%BB%BB%E5%8A%A1%E8%BF%9B%E8%A1%8C%E7%82%B9%E7%81%AF%E5%AE%9E%E6%93%8D"><span class="toc-number">4.0.3.</span> <span class="toc-text">创建两个任务进行点灯实操</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-number">5.</span> <span class="toc-text">任务调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%EF%BC%9F"><span class="toc-number">5.0.1.</span> <span class="toc-text">什么是任务调度？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FreeRTOS%E7%9A%84%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E8%A7%84%E5%88%99%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">5.0.2.</span> <span class="toc-text">FreeRTOS的任务调度规则是怎样的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">5.0.3.</span> <span class="toc-text">抢占式调度运行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%B0%83%E5%BA%A6%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">5.0.4.</span> <span class="toc-text">时间片调度运行过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81"><span class="toc-number">6.</span> <span class="toc-text">任务状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-number">7.</span> <span class="toc-text">任务调度和任务的状态案例分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">8.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">8.1.</span> <span class="toc-text">什么是队列？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3-API-%E5%87%BD%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text">消息队列相关 API 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%98%9F%E5%88%97"><span class="toc-number">8.2.1.</span> <span class="toc-text">创建队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E9%98%9F%E5%88%97"><span class="toc-number">8.2.2.</span> <span class="toc-text">写队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E9%98%9F%E5%88%97"><span class="toc-number">8.2.3.</span> <span class="toc-text">读队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9E%E6%93%8D"><span class="toc-number">8.3.</span> <span class="toc-text">消息队列实操</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">9.</span> <span class="toc-text">二值信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%9F"><span class="toc-number">9.1.</span> <span class="toc-text">什么是信号量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%9F"><span class="toc-number">9.2.</span> <span class="toc-text">什么是二值信号量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9B%B8%E5%85%B3-API-%E5%87%BD%E6%95%B0"><span class="toc-number">9.3.</span> <span class="toc-text">二值信号量相关 API 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">9.3.1.</span> <span class="toc-text">创建二值信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">9.3.2.</span> <span class="toc-text">释放二值信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">9.3.3.</span> <span class="toc-text">获取二值信号量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E6%93%8D"><span class="toc-number">9.4.</span> <span class="toc-text">二值信号量实操</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">10.</span> <span class="toc-text">计数型信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E6%95%B0%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%9F"><span class="toc-number">10.1.</span> <span class="toc-text">什么是计数型信号量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9B%B8%E5%85%B3-API-%E5%87%BD%E6%95%B0"><span class="toc-number">10.2.</span> <span class="toc-text">计数型信号量相关 API 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%AE%A1%E6%95%B0%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">10.2.1.</span> <span class="toc-text">创建计数型信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E8%AE%A1%E6%95%B0%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">10.2.2.</span> <span class="toc-text">释放计数型信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%AE%A1%E6%95%B0%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">10.2.3.</span> <span class="toc-text">获取计数型信号量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E6%93%8D"><span class="toc-number">10.3.</span> <span class="toc-text">计数型信号量实操</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-number">11.</span> <span class="toc-text">互斥量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%92%E6%96%A5%E9%87%8F%EF%BC%9F"><span class="toc-number">11.1.</span> <span class="toc-text">什么是互斥量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC%EF%BC%88%E7%BF%BB%E8%BD%AC%EF%BC%89%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7%E7%BB%A7%E6%89%BF"><span class="toc-number">11.2.</span> <span class="toc-text">什么是优先级反转（翻转）和优先级继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F%E7%9B%B8%E5%85%B3-API-%E5%87%BD%E6%95%B0"><span class="toc-number">11.3.</span> <span class="toc-text">互斥量相关 API 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC%EF%BC%88%E7%BF%BB%E8%BD%AC%EF%BC%89%E7%A4%BA%E4%BE%8B"><span class="toc-number">11.4.</span> <span class="toc-text">优先级反转（翻转）示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%87%8F%E4%BC%98%E5%8C%96%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC%EF%BC%88%E7%BF%BB%E8%BD%AC%EF%BC%89%E9%97%AE%E9%A2%98%E7%A4%BA%E4%BE%8B"><span class="toc-number">11.5.</span> <span class="toc-text">使用互斥量优化优先级反转（翻转）问题示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84"><span class="toc-number">12.</span> <span class="toc-text">事件标志组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84%EF%BC%9F"><span class="toc-number">12.1.</span> <span class="toc-text">什么是事件标志组？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84%E7%9B%B8%E5%85%B3-API-%E5%87%BD%E6%95%B0"><span class="toc-number">12.2.</span> <span class="toc-text">事件标志组相关 API 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84"><span class="toc-number">12.2.1.</span> <span class="toc-text">创建事件标志组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="toc-number">12.2.2.</span> <span class="toc-text">设置事件标志位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="toc-number">12.2.3.</span> <span class="toc-text">清除事件标志位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="toc-number">12.2.4.</span> <span class="toc-text">等待事件标志位</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84%E5%AE%9E%E6%93%8D"><span class="toc-number">12.3.</span> <span class="toc-text">事件标志组实操</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5"><span class="toc-number">13.</span> <span class="toc-text">任务通知</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%EF%BC%9F"><span class="toc-number">13.1.</span> <span class="toc-text">什么是任务通知？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E9%80%9A%E7%9F%A5%E7%BB%99%E4%BB%BB%E5%8A%A1-%EF%BC%9A"><span class="toc-number">13.2.</span> <span class="toc-text">发送通知给任务 ：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E5%8A%A3%E5%8A%BF"><span class="toc-number">13.3.</span> <span class="toc-text">任务通知的优势和劣势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E7%9B%B8%E5%85%B3-API-%E5%87%BD%E6%95%B0"><span class="toc-number">13.4.</span> <span class="toc-text">任务通知相关 API 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E9%80%9A%E7%9F%A5"><span class="toc-number">13.4.1.</span> <span class="toc-text">发送通知</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5"><span class="toc-number">13.4.2.</span> <span class="toc-text">等待通知</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E5%AE%9E%E6%93%8D"><span class="toc-number">13.5.</span> <span class="toc-text">任务通知实操</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">13.5.1.</span> <span class="toc-text">模拟二值信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E8%AE%A1%E6%95%B0%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">13.5.2.</span> <span class="toc-text">模拟计数型信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84"><span class="toc-number">13.5.3.</span> <span class="toc-text">模拟事件标志组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E6%B6%88%E6%81%AF%E9%82%AE%E7%AE%B1"><span class="toc-number">13.5.4.</span> <span class="toc-text">模拟消息邮箱</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0%E5%92%8C%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">14.</span> <span class="toc-text">延时函数和软件定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">14.1.</span> <span class="toc-text">什么是延时函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0%E5%88%86%E7%B1%BB"><span class="toc-number">14.2.</span> <span class="toc-text">延时函数分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%9F"><span class="toc-number">14.3.</span> <span class="toc-text">什么是定时器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9B%B8%E5%85%B3-API-%E5%87%BD%E6%95%B0"><span class="toc-number">14.4.</span> <span class="toc-text">软件定时器相关 API 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">14.4.1.</span> <span class="toc-text">创建软件定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">14.4.2.</span> <span class="toc-text">开启软件定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">14.4.3.</span> <span class="toc-text">停止软件定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E4%BD%8D%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">14.4.4.</span> <span class="toc-text">复位软件定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9A%E6%97%B6%E6%97%B6%E9%97%B4"><span class="toc-number">14.4.5.</span> <span class="toc-text">更改软件定时器定时时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0%E5%92%8C%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E6%93%8D"><span class="toc-number">14.5.</span> <span class="toc-text">延时函数和软件定时器实操</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86"><span class="toc-number">15.</span> <span class="toc-text">中断管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%AE%9A%E4%B9%89"><span class="toc-number">15.1.</span> <span class="toc-text">中断定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">15.2.</span> <span class="toc-text">中断优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">15.3.</span> <span class="toc-text">中断相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97-1"><span class="toc-number">15.3.1.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">15.3.2.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84-1"><span class="toc-number">15.3.3.</span> <span class="toc-text">事件标志组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5-1"><span class="toc-number">15.3.4.</span> <span class="toc-text">任务通知</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">15.3.5.</span> <span class="toc-text">软件定时器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86%E5%AE%9E%E6%93%8D"><span class="toc-number">15.4.</span> <span class="toc-text">中断管理实操</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/05/13/FreeRTOS/" title="FreeRTOS"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/05/13/IAYeaBKD.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="FreeRTOS"/></a><div class="content"><a class="title" href="/2024/05/13/FreeRTOS/" title="FreeRTOS">FreeRTOS</a><time datetime="2024-05-13T08:06:10.000Z" title="发表于 2024-05-13 16:06:10">2024-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/13/ADC%E5%92%8CDMA/" title="ADC和DMA"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/05/13/dLVYfxUA.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ADC和DMA"/></a><div class="content"><a class="title" href="/2024/05/13/ADC%E5%92%8CDMA/" title="ADC和DMA">ADC和DMA</a><time datetime="2024-05-13T02:02:48.000Z" title="发表于 2024-05-13 10:02:48">2024-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/12/STM32/" title="STM32 HAL库版本"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/05/12/YamYeyQj.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="STM32 HAL库版本"/></a><div class="content"><a class="title" href="/2024/05/12/STM32/" title="STM32 HAL库版本">STM32 HAL库版本</a><time datetime="2024-05-12T08:57:38.000Z" title="发表于 2024-05-12 16:57:38">2024-05-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/04/Linux%E7%BA%BF%E7%A8%8B/" title="Linux线程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/05/05/Bg6p4Ceu.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux线程"/></a><div class="content"><a class="title" href="/2024/05/04/Linux%E7%BA%BF%E7%A8%8B/" title="Linux线程">Linux线程</a><time datetime="2024-05-04T08:35:39.000Z" title="发表于 2024-05-04 16:35:39">2024-05-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/04/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%A8%A1%E6%9D%BF/" title="简单工厂模式"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2.imgtp.com/2024/05/08/MIkSgHhh.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="简单工厂模式"/></a><div class="content"><a class="title" href="/2024/05/04/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%A8%A1%E6%9D%BF/" title="简单工厂模式">简单工厂模式</a><time datetime="2024-05-04T08:35:39.000Z" title="发表于 2024-05-04 16:35:39">2024-05-04</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="Ten" target="_blank">Ten</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">5</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/"><span> 音乐馆</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/FreeRTOS/" style="font-size: 0.88rem;">FreeRTOS<sup>1</sup></a><a href="/tags/STM32/" style="font-size: 0.88rem;">STM32<sup>2</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>8</sup></a><a href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 0.88rem;">单片机<sup>2</sup></a><a href="/tags/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/" style="font-size: 0.88rem;">实战项目<sup>1</sup></a><a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" style="font-size: 0.88rem;">嵌入式<sup>3</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">线程<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 0.88rem;">网络编程<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>1</sup></a><a href="/tags/%E8%BF%9B%E7%A8%8B/" style="font-size: 0.88rem;">进程<sup>2</sup></a><a href="/tags/%E9%80%9A%E4%BF%A1/" style="font-size: 0.88rem;">通信<sup>1</sup></a><a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 0.88rem;">随笔<sup>2</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'default' : 'light'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>